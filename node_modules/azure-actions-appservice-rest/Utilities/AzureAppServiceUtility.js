"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AzureAppServiceUtility = void 0;
const WebClient_1 = require("azure-actions-webclient/WebClient");
const azure_app_kudu_service_1 = require("../Kudu/azure-app-kudu-service");
const Q = require("q");
const core = require("@actions/core");
var parseString = require('xml2js').parseString;
class AzureAppServiceUtility {
    constructor(appService) {
        this._appService = appService;
        this._webClient = new WebClient_1.WebClient();
    }
    getWebDeployPublishingProfile() {
        return __awaiter(this, void 0, void 0, function* () {
            var publishingProfile = yield this._appService.getPublishingProfileWithSecrets();
            var defer = Q.defer();
            parseString(publishingProfile, (error, result) => {
                if (!!error) {
                    defer.reject(error);
                }
                var publishProfile = result && result.publishData && result.publishData.publishProfile ? result.publishData.publishProfile : null;
                if (publishProfile) {
                    for (var index in publishProfile) {
                        if (publishProfile[index].$ && publishProfile[index].$.publishMethod === "MSDeploy") {
                            defer.resolve(result.publishData.publishProfile[index].$);
                        }
                    }
                }
                defer.reject('Error : No such deploying method exists.');
            });
            return defer.promise;
        });
    }
    getApplicationURL(virtualApplication) {
        return __awaiter(this, void 0, void 0, function* () {
            let webDeployProfile = yield this.getWebDeployPublishingProfile();
            return (yield webDeployProfile.destinationAppUrl) + (virtualApplication ? "/" + virtualApplication : "");
        });
    }
    pingApplication() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                var applicationUrl = yield this.getApplicationURL();
                if (!applicationUrl) {
                    core.debug("Application Url not found.");
                    return;
                }
                yield this.pingApplicationWithUrl(applicationUrl);
            }
            catch (error) {
                core.debug("Unable to ping App Service. Error: ${error}");
            }
        });
    }
    pingApplicationWithUrl(applicationUrl) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!applicationUrl) {
                core.debug('Application Url empty.');
                return;
            }
            try {
                var webRequest = {
                    method: 'GET',
                    uri: applicationUrl
                };
                let webRequestOptions = { retriableErrorCodes: [], retriableStatusCodes: [], retryCount: 1, retryIntervalInSeconds: 5, retryRequestTimedout: true };
                var response = yield this._webClient.sendRequest(webRequest, webRequestOptions);
                core.debug(`App Service status Code: '${response.statusCode}'. Status Message: '${response.statusMessage}'`);
            }
            catch (error) {
                core.debug(`Unable to ping App Service. Error: ${error}`);
            }
        });
    }
    /**
     * Gets a Kudu service client for deployments.
     * @param warmupInstanceId Optional instance ID for SPN auth to pin all requests to a single instance (ARRAffinity cookie)
     */
    getKuduService(warmupInstanceId) {
        return __awaiter(this, void 0, void 0, function* () {
            // Build cookie if warmupInstanceId is provided (for SPN to pin to specific instance)
            const cookie = warmupInstanceId
                ? [`ARRAffinity=${warmupInstanceId}`, `ARRAffinitySameSite=${warmupInstanceId}`]
                : undefined;
            try {
                const token = yield this._appService.getAccessToken();
                if (!!token) {
                    console.log(`::add-mask::${token}`);
                    const app = yield this._appService.get();
                    const scmUri = (app.properties["hostNameSslStates"] || []).find(n => n.hostType == "Repository");
                    if (!!scmUri) {
                        return new azure_app_kudu_service_1.Kudu(`https://${scmUri["name"]}`, token, cookie);
                    }
                }
            }
            catch (e) {
                console.log('Error getting accessToken. Falling back to publishing profile: ' + e);
            }
            var publishingCredentials = yield this._appService.getPublishingCredentials();
            if (publishingCredentials.properties["scmUri"]) {
                let username = publishingCredentials.properties["publishingUserName"];
                let password = publishingCredentials.properties["publishingPassword"];
                // masking kudu password
                console.log(`::add-mask::${password}`);
                // For publish profile, don't pass cookie - it will be captured from response
                return new azure_app_kudu_service_1.Kudu(publishingCredentials.properties["scmUri"], { username, password });
            }
            throw Error('KUDU SCM details are empty');
        });
    }
    /**
     * Gets the first available instance ID for warmup cookie pinning.
     * Used with SPN authentication to ensure all requests go to the same instance.
     * Sorts instances by name and picks the first one (similar to az-cli behavior).
     * @returns Instance ID string, or undefined if not available
     */
    getWarmupInstanceId() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const instances = yield this._appService.getAppServiceInstances();
                if (((_a = instances === null || instances === void 0 ? void 0 : instances.value) === null || _a === void 0 ? void 0 : _a.length) > 0) {
                    // Sort by name and pick the first one (consistent with az-cli)
                    const sortedInstances = instances.value.sort((a, b) => a.name.localeCompare(b.name));
                    const instanceId = sortedInstances[0].name;
                    core.debug(`Got warmup instance ID: ${instanceId}`);
                    return instanceId;
                }
                core.debug('No instances found for warmup');
                return undefined;
            }
            catch (error) {
                core.debug(`Failed to get instances for warmup: ${error}`);
                return undefined;
            }
        });
    }
    updateConfigurationSettings(properties) {
        return __awaiter(this, void 0, void 0, function* () {
            for (var property in properties) {
                if (!!properties[property] && properties[property].value !== undefined) {
                    properties[property] = properties[property].value;
                }
            }
            console.log('Updating App Service Configuration settings. Data: ' + JSON.stringify(properties));
            yield this._appService.patchConfiguration({ 'properties': properties });
            console.log('Updated App Service Configuration settings.');
        });
    }
    updateAndMonitorAppSettings(addProperties, deleteProperties) {
        return __awaiter(this, void 0, void 0, function* () {
            var appSettingsProperties = {};
            for (var property in addProperties) {
                appSettingsProperties[addProperties[property].name] = addProperties[property].value;
            }
            if (!!addProperties) {
                console.log('Updating App Service Application settings. Data: ' + JSON.stringify(appSettingsProperties));
            }
            if (!!deleteProperties) {
                console.log('Deleting App Service Application settings. Data: ' + JSON.stringify(Object.keys(deleteProperties)));
            }
            var isNewValueUpdated = yield this._appService.patchApplicationSettings(appSettingsProperties, deleteProperties);
            yield this._appService.patchApplicationSettingsSlot(addProperties);
            if (!!isNewValueUpdated) {
                console.log('Updated App Service Application settings.');
            }
            return isNewValueUpdated;
        });
    }
    updateConnectionStrings(addProperties) {
        return __awaiter(this, void 0, void 0, function* () {
            var connectionStringProperties = {};
            for (var property in addProperties) {
                if (!addProperties[property].type) {
                    addProperties[property].type = "Custom";
                }
                if (!addProperties[property].slotSetting) {
                    addProperties[property].slotSetting = false;
                }
                connectionStringProperties[addProperties[property].name] = addProperties[property];
                delete connectionStringProperties[addProperties[property].name].name;
            }
            console.log('Updating App Service Connection Strings. Data: ' + JSON.stringify(connectionStringProperties));
            var isNewValueUpdated = yield this._appService.patchConnectionString(connectionStringProperties);
            yield this._appService.patchConnectionStringSlot(connectionStringProperties);
            if (!!isNewValueUpdated) {
                console.log('Updated App Service Connection Strings.');
            }
            return isNewValueUpdated;
        });
    }
}
exports.AzureAppServiceUtility = AzureAppServiceUtility;
