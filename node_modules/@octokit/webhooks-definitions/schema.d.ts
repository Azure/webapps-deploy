/* tslint:disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type Schema =
  | CheckRunEvent
  | CheckSuiteEvent
  | CodeScanningAlertEvent
  | CommitCommentEvent
  | ContentReferenceEvent
  | CreateEvent
  | DeleteEvent
  | DeployKeyEvent
  | DeploymentEvent
  | DeploymentStatusEvent
  | DiscussionEvent
  | DiscussionCommentEvent
  | ForkEvent
  | GithubAppAuthorizationEvent
  | GollumEvent
  | InstallationEvent
  | InstallationRepositoriesEvent
  | IssueCommentEvent
  | IssuesEvent
  | LabelEvent
  | MarketplacePurchaseEvent
  | MemberEvent
  | MembershipEvent
  | MetaEvent
  | MilestoneEvent
  | OrgBlockEvent
  | OrganizationEvent
  | PackageEvent
  | PageBuildEvent
  | PingEvent
  | ProjectEvent
  | ProjectCardEvent
  | ProjectColumnEvent
  | PublicEvent
  | PullRequestEvent
  | PullRequestReviewEvent
  | PullRequestReviewCommentEvent
  | PushEvent
  | ReleaseEvent
  | RepositoryEvent
  | RepositoryDispatchEvent
  | RepositoryImportEvent
  | RepositoryVulnerabilityAlertEvent
  | SecretScanningAlertEvent
  | SecurityAdvisoryEvent
  | SponsorshipEvent
  | StarEvent
  | StatusEvent
  | TeamEvent
  | TeamAddEvent
  | WatchEvent
  | WorkflowDispatchEvent
  | WorkflowRunEvent;
export type CheckRunEvent =
  | CheckRunCompletedEvent
  | CheckRunCreatedEvent
  | CheckRunRequestedActionEvent
  | CheckRunRerequestedEvent;
export type CheckSuiteEvent =
  | CheckSuiteCompletedEvent
  | CheckSuiteRequestedEvent
  | CheckSuiteRerequestedEvent;
export type CodeScanningAlertEvent =
  | CodeScanningAlertAppearedInBranchEvent
  | CodeScanningAlertClosedByUserEvent
  | CodeScanningAlertCreatedEvent
  | CodeScanningAlertFixedEvent
  | CodeScanningAlertReopenedEvent
  | CodeScanningAlertReopenedByUserEvent;
export type CommitCommentEvent = CommitCommentCreatedEvent;
/**
 * How the author is associated with the repository.
 */
export type AuthorAssociation =
  | "COLLABORATOR"
  | "CONTRIBUTOR"
  | "FIRST_TIMER"
  | "FIRST_TIME_CONTRIBUTOR"
  | "MANNEQUIN"
  | "MEMBER"
  | "NONE"
  | "OWNER";
export type ContentReferenceEvent = ContentReferenceCreatedEvent;
export type DeployKeyEvent = DeployKeyCreatedEvent | DeployKeyDeletedEvent;
export type DeploymentEvent = DeploymentCreatedEvent;
export type DeploymentStatusEvent = DeploymentStatusCreatedEvent;
export type DiscussionEvent =
  | DiscussionAnsweredEvent
  | DiscussionCategoryChangedEvent
  | DiscussionCreatedEvent
  | DiscussionDeletedEvent
  | DiscussionEditedEvent
  | DiscussionLockedEvent
  | DiscussionPinnedEvent
  | DiscussionTransferredEvent
  | DiscussionUnansweredEvent
  | DiscussionUnlockedEvent
  | DiscussionUnpinnedEvent;
export type DiscussionCommentEvent =
  | DiscussionCommentCreatedEvent
  | DiscussionCommentDeletedEvent
  | DiscussionCommentEditedEvent;
export type GithubAppAuthorizationEvent = GithubAppAuthorizationRevokedEvent;
export type InstallationEvent =
  | InstallationCreatedEvent
  | InstallationDeletedEvent
  | InstallationNewPermissionsAcceptedEvent
  | InstallationSuspendEvent
  | InstallationUnsuspendEvent;
export type InstallationRepositoriesEvent =
  | InstallationRepositoriesAddedEvent
  | InstallationRepositoriesRemovedEvent;
export type IssueCommentEvent =
  | IssueCommentCreatedEvent
  | IssueCommentDeletedEvent
  | IssueCommentEditedEvent;
export type IssuesEvent =
  | IssuesAssignedEvent
  | IssuesClosedEvent
  | IssuesDeletedEvent
  | IssuesDemilestonedEvent
  | IssuesEditedEvent
  | IssuesLabeledEvent
  | IssuesLockedEvent
  | IssuesMilestonedEvent
  | IssuesOpenedEvent
  | IssuesPinnedEvent
  | IssuesReopenedEvent
  | IssuesTransferredEvent
  | IssuesUnassignedEvent
  | IssuesUnlabeledEvent
  | IssuesUnlockedEvent
  | IssuesUnpinnedEvent;
export type LabelEvent =
  | LabelCreatedEvent
  | LabelDeletedEvent
  | LabelEditedEvent;
export type MarketplacePurchaseEvent =
  | MarketplacePurchaseCancelledEvent
  | MarketplacePurchaseChangedEvent
  | MarketplacePurchasePendingChangeEvent
  | MarketplacePurchasePendingChangeCancelledEvent
  | MarketplacePurchasePurchasedEvent;
export type MemberEvent =
  | MemberAddedEvent
  | MemberEditedEvent
  | MemberRemovedEvent;
export type MembershipEvent = MembershipAddedEvent | MembershipRemovedEvent;
export type MetaEvent = MetaDeletedEvent;
export type MilestoneEvent =
  | MilestoneClosedEvent
  | MilestoneCreatedEvent
  | MilestoneDeletedEvent
  | MilestoneEditedEvent
  | MilestoneOpenedEvent;
export type OrgBlockEvent = OrgBlockBlockedEvent | OrgBlockUnblockedEvent;
export type OrganizationEvent =
  | OrganizationDeletedEvent
  | OrganizationMemberAddedEvent
  | OrganizationMemberInvitedEvent
  | OrganizationMemberRemovedEvent
  | OrganizationRenamedEvent;
export type PackageEvent = PackagePublishedEvent | PackageUpdatedEvent;
export type ProjectEvent =
  | ProjectClosedEvent
  | ProjectCreatedEvent
  | ProjectDeletedEvent
  | ProjectEditedEvent
  | ProjectReopenedEvent;
export type ProjectCardEvent =
  | ProjectCardConvertedEvent
  | ProjectCardCreatedEvent
  | ProjectCardDeletedEvent
  | ProjectCardEditedEvent
  | ProjectCardMovedEvent;
export type ProjectColumnEvent =
  | ProjectColumnCreatedEvent
  | ProjectColumnDeletedEvent
  | ProjectColumnEditedEvent
  | ProjectColumnMovedEvent;
export type PullRequestEvent =
  | PullRequestAssignedEvent
  | PullRequestAutoMergeDisabledEvent
  | PullRequestAutoMergeEnabledEvent
  | PullRequestClosedEvent
  | PullRequestConvertedToDraftEvent
  | PullRequestEditedEvent
  | PullRequestLabeledEvent
  | PullRequestLockedEvent
  | PullRequestOpenedEvent
  | PullRequestReadyForReviewEvent
  | PullRequestReopenedEvent
  | PullRequestReviewRequestRemovedEvent
  | PullRequestReviewRequestedEvent
  | PullRequestSynchronizeEvent
  | PullRequestUnassignedEvent
  | PullRequestUnlabeledEvent
  | PullRequestUnlockedEvent;
export type PullRequestReviewEvent =
  | PullRequestReviewDismissedEvent
  | PullRequestReviewEditedEvent
  | PullRequestReviewSubmittedEvent;
export type PullRequestReviewCommentEvent =
  | PullRequestReviewCommentCreatedEvent
  | PullRequestReviewCommentDeletedEvent
  | PullRequestReviewCommentEditedEvent;
export type ReleaseEvent =
  | ReleaseCreatedEvent
  | ReleaseDeletedEvent
  | ReleaseEditedEvent
  | ReleasePrereleasedEvent
  | ReleasePublishedEvent
  | ReleaseReleasedEvent
  | ReleaseUnpublishedEvent;
export type RepositoryEvent =
  | RepositoryArchivedEvent
  | RepositoryCreatedEvent
  | RepositoryDeletedEvent
  | RepositoryEditedEvent
  | RepositoryPrivatizedEvent
  | RepositoryPublicizedEvent
  | RepositoryRenamedEvent
  | RepositoryTransferredEvent
  | RepositoryUnarchivedEvent;
export type RepositoryDispatchEvent = RepositoryDispatchOnDemandTestEvent;
export type RepositoryVulnerabilityAlertEvent =
  | RepositoryVulnerabilityAlertCreateEvent
  | RepositoryVulnerabilityAlertDismissEvent
  | RepositoryVulnerabilityAlertResolveEvent;
export type SecretScanningAlertEvent =
  | SecretScanningAlertCreatedEvent
  | SecretScanningAlertReopenedEvent
  | SecretScanningAlertResolvedEvent;
export type SecurityAdvisoryEvent =
  | SecurityAdvisoryPerformedEvent
  | SecurityAdvisoryPublishedEvent
  | SecurityAdvisoryUpdatedEvent;
export type SponsorshipEvent =
  | SponsorshipCancelledEvent
  | SponsorshipCreatedEvent
  | SponsorshipEditedEvent
  | SponsorshipPendingCancellationEvent
  | SponsorshipPendingTierChangeEvent
  | SponsorshipTierChangedEvent;
export type StarEvent = StarCreatedEvent | StarDeletedEvent;
export type TeamEvent =
  | TeamAddedToRepositoryEvent
  | TeamCreatedEvent
  | TeamDeletedEvent
  | TeamEditedEvent
  | TeamRemovedFromRepositoryEvent;
export type WatchEvent = WatchStartedEvent;
export type WorkflowRunEvent =
  | WorkflowRunCompletedEvent
  | WorkflowRunRequestedEvent;

export interface CheckRunCompletedEvent {
  action: "completed";
  /**
   * The [check_run](https://docs.github.com/en/rest/reference/checks#get-a-check-run).
   */
  check_run: {
    /**
     * The id of the check.
     */
    id: number;
    node_id?: string;
    /**
     * The SHA of the commit that is being checked.
     */
    head_sha: string;
    external_id: string;
    url: string;
    html_url: string;
    details_url?: string;
    /**
     * The current status of the check run. Can be `queued`, `in_progress`, or `completed`.
     */
    status: "completed";
    /**
     * The result of the completed check run. Can be one of `success`, `failure`, `neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has completed.
     */
    conclusion:
      | "success"
      | "failure"
      | "neutral"
      | "cancelled"
      | "timed_out"
      | "action_required"
      | "stale"
      | null;
    /**
     * The time that the check run began. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
     */
    started_at: string;
    /**
     * The time the check completed. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
     */
    completed_at: string;
    output: {
      title?: string | null;
      summary: string | null;
      text: string | null;
      annotations_count: number;
      annotations_url: string;
    };
    /**
     * The name of the check run.
     */
    name: string;
    check_suite: {
      /**
       * The id of the check suite that this check run is part of.
       */
      id: number;
      node_id?: string;
      head_branch: string | null;
      /**
       * The SHA of the head commit that is being checked.
       */
      head_sha: string;
      status: "in_progress" | "completed";
      conclusion:
        | "success"
        | "failure"
        | "neutral"
        | "cancelled"
        | "timed_out"
        | "action_required"
        | "stale"
        | null;
      url: string;
      before: string | null;
      after: string | null;
      /**
       * An array of pull requests that match this check suite. A pull request matches a check suite if they have the same `head_sha` and `head_branch`. When the check suite's `head_branch` is in a forked repository it will be `null` and the `pull_requests` array will be empty.
       */
      pull_requests: CheckRunPullRequest[];
      app: App;
      created_at: string;
      updated_at: string;
    };
    app: App;
    pull_requests: CheckRunPullRequest[];
    deployment?: CheckRunDeployment;
  };
  /**
   * The action requested by the user.
   */
  requested_action?: {
    /**
     * The integrator reference of the action requested by the user.
     */
    identifier?: string;
  } | null;
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface CheckRunPullRequest {
  url: string;
  id: number;
  number: number;
  head: {
    ref: string;
    sha: string;
    repo: RepoRef;
  };
  base: {
    ref: string;
    sha: string;
    repo: RepoRef;
  };
}
export interface RepoRef {
  id: number;
  url: string;
  name: string;
}
/**
 * GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
 */
export interface App {
  /**
   * Unique identifier of the GitHub app
   */
  id: number;
  /**
   * The slug name of the GitHub app
   */
  slug?: string;
  node_id: string;
  owner: User;
  /**
   * The name of the GitHub app
   */
  name: string;
  description: string | null;
  external_url: string;
  html_url: string;
  created_at: string;
  updated_at: string;
  /**
   * The set of permissions for the GitHub app
   */
  permissions?: {
    administration?: "read" | "write";
    actions?: "read" | "write";
    checks?: "read" | "write";
    contents?: "read" | "write";
    deployments?: "read" | "write";
    issues?: "read" | "write";
    members?: "read" | "write";
    emails?: "read" | "write";
    metadata?: "read" | "write";
    organization_administration?: "read" | "write";
    organization_hooks?: "read" | "write";
    organization_packages?: "read" | "write";
    organization_plan?: "read" | "write";
    organization_projects?: "read" | "write";
    organization_user_blocking?: "read" | "write";
    pages?: "read" | "write";
    packages?: "read" | "write";
    pull_requests?: "read" | "write";
    repository_hooks?: "read" | "write";
    repository_projects?: "read" | "write";
    security_events?: "read" | "write";
    statuses?: "read" | "write";
    team_discussions?: "read" | "write";
    vulnerability_alerts?: "read" | "write";
  };
  /**
   * The list of events for the GitHub app
   */
  events?: string[];
}
export interface User {
  login: string;
  id: number;
  node_id: string;
  name?: string;
  email?: string | null;
  avatar_url: string;
  gravatar_id: string;
  url: string;
  html_url: string;
  followers_url: string;
  following_url: string;
  gists_url: string;
  starred_url: string;
  subscriptions_url: string;
  organizations_url: string;
  repos_url: string;
  events_url: string;
  received_events_url: string;
  type: "Bot" | "User" | "Organization";
  site_admin: boolean;
}
/**
 * A deployment to a repository environment. This will only be populated if the check run was created by a GitHub Actions workflow job that references an environment.
 */
export interface CheckRunDeployment {
  url: string;
  id: number;
  node_id: string;
  task: string;
  original_environment: string;
  environment: string;
  description: string | null;
  created_at: string;
  updated_at: string;
  statuses_url: string;
  repository_url: string;
}
/**
 * A git repository
 */
export interface Repository {
  /**
   * Unique identifier of the repository
   */
  id: number;
  node_id: string;
  /**
   * The name of the repository.
   */
  name: string;
  full_name: string;
  /**
   * Whether the repository is private or public.
   */
  private: boolean;
  owner: User;
  html_url: string;
  description: string | null;
  fork: boolean;
  url: string;
  forks_url: string;
  keys_url: string;
  collaborators_url: string;
  teams_url: string;
  hooks_url: string;
  issue_events_url: string;
  events_url: string;
  assignees_url: string;
  branches_url: string;
  tags_url: string;
  blobs_url: string;
  git_tags_url: string;
  git_refs_url: string;
  trees_url: string;
  statuses_url: string;
  languages_url: string;
  stargazers_url: string;
  contributors_url: string;
  subscribers_url: string;
  subscription_url: string;
  commits_url: string;
  git_commits_url: string;
  comments_url: string;
  issue_comment_url: string;
  contents_url: string;
  compare_url: string;
  merges_url: string;
  archive_url: string;
  downloads_url: string;
  issues_url: string;
  pulls_url: string;
  milestones_url: string;
  notifications_url: string;
  labels_url: string;
  releases_url: string;
  deployments_url: string;
  created_at: number | string;
  updated_at: string;
  pushed_at: number | string;
  git_url: string;
  ssh_url: string;
  clone_url: string;
  svn_url: string;
  homepage: string | null;
  size: number;
  stargazers_count: number;
  watchers_count: number;
  language: string | null;
  /**
   * Whether issues are enabled.
   */
  has_issues: boolean;
  /**
   * Whether projects are enabled.
   */
  has_projects: boolean;
  /**
   * Whether downloads are enabled.
   */
  has_downloads: boolean;
  /**
   * Whether the wiki is enabled.
   */
  has_wiki: boolean;
  has_pages: boolean;
  forks_count: number;
  mirror_url: string | null;
  /**
   * Whether the repository is archived.
   */
  archived: boolean;
  /**
   * Returns whether or not this repository is disabled.
   */
  disabled?: boolean;
  open_issues_count: number;
  license: License | null;
  forks: number;
  open_issues: number;
  watchers: number;
  stargazers?: number;
  /**
   * The default branch of the repository.
   */
  default_branch: string;
  /**
   * Whether to allow squash merges for pull requests.
   */
  allow_squash_merge?: boolean;
  /**
   * Whether to allow merge commits for pull requests.
   */
  allow_merge_commit?: boolean;
  /**
   * Whether to allow rebase merges for pull requests.
   */
  allow_rebase_merge?: boolean;
  /**
   * Whether to delete head branches when pull requests are merged
   */
  delete_branch_on_merge?: boolean;
  master_branch?: string;
  permissions?: {
    pull: boolean;
    push: boolean;
    admin: boolean;
    maintain?: boolean;
    triage?: boolean;
  };
  public?: boolean;
  organization?: string;
}
export interface License {
  key: string;
  name: string;
  spdx_id: string;
  url: string | null;
  node_id: string;
}
/**
 * Installation
 */
export interface InstallationLite {
  /**
   * The ID of the installation.
   */
  id: number;
  node_id: string;
}
export interface Organization {
  login: string;
  id: number;
  node_id: string;
  url: string;
  html_url?: string;
  repos_url: string;
  events_url: string;
  hooks_url: string;
  issues_url: string;
  members_url: string;
  public_members_url: string;
  avatar_url: string;
  description: string | null;
}
export interface CheckRunCreatedEvent {
  action: "created";
  /**
   * The [check_run](https://docs.github.com/en/rest/reference/checks#get-a-check-run).
   */
  check_run: {
    /**
     * The id of the check.
     */
    id: number;
    node_id?: string;
    /**
     * The SHA of the commit that is being checked.
     */
    head_sha: string;
    external_id: string;
    url: string;
    html_url: string;
    details_url?: string;
    /**
     * The current status of the check run. Can be `queued`, `in_progress`, or `completed`.
     */
    status: "queued" | "in_progress";
    /**
     * The result of the completed check run. Can be one of `success`, `failure`, `neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has completed.
     */
    conclusion:
      | "success"
      | "failure"
      | "neutral"
      | "cancelled"
      | "timed_out"
      | "action_required"
      | "stale"
      | null;
    /**
     * The time that the check run began. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
     */
    started_at: string;
    /**
     * The time the check completed. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
     */
    completed_at: string | null;
    output: {
      title?: string | null;
      summary: string | null;
      text: string | null;
      annotations_count: number;
      annotations_url: string;
    };
    /**
     * The name of the check run.
     */
    name: string;
    check_suite: {
      /**
       * The id of the check suite that this check run is part of.
       */
      id: number;
      node_id?: string;
      head_branch: string | null;
      /**
       * The SHA of the head commit that is being checked.
       */
      head_sha: string;
      status: "queued" | "in_progress";
      conclusion: null;
      url: string;
      before: string | null;
      after: string | null;
      /**
       * An array of pull requests that match this check suite. A pull request matches a check suite if they have the same `head_sha` and `head_branch`. When the check suite's `head_branch` is in a forked repository it will be `null` and the `pull_requests` array will be empty.
       */
      pull_requests: CheckRunPullRequest[];
      app: App;
      created_at: string;
      updated_at: string;
    };
    app: App;
    pull_requests: CheckRunPullRequest[];
    deployment?: CheckRunDeployment;
  };
  /**
   * The action requested by the user.
   */
  requested_action?: {
    /**
     * The integrator reference of the action requested by the user.
     */
    identifier?: string;
  } | null;
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface CheckRunRequestedActionEvent {
  action: "requested_action";
  /**
   * The [check_run](https://docs.github.com/en/rest/reference/checks#get-a-check-run).
   */
  check_run: {
    /**
     * The id of the check.
     */
    id: number;
    node_id?: string;
    /**
     * The SHA of the commit that is being checked.
     */
    head_sha: string;
    external_id: string;
    url: string;
    html_url: string;
    details_url?: string;
    /**
     * The current status of the check run. Can be `queued`, `in_progress`, or `completed`.
     */
    status: "queued" | "in_progress" | "completed";
    /**
     * The result of the completed check run. Can be one of `success`, `failure`, `neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has completed.
     */
    conclusion:
      | "success"
      | "failure"
      | "neutral"
      | "cancelled"
      | "timed_out"
      | "action_required"
      | "stale"
      | null;
    /**
     * The time that the check run began. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
     */
    started_at: string;
    /**
     * The time the check completed. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
     */
    completed_at: string | null;
    output: {
      title?: string | null;
      summary: string | null;
      text: string | null;
      annotations_count: number;
      annotations_url: string;
    };
    /**
     * The name of the check run.
     */
    name: string;
    check_suite: {
      /**
       * The id of the check suite that this check run is part of.
       */
      id: number;
      node_id?: string;
      head_branch: string | null;
      /**
       * The SHA of the head commit that is being checked.
       */
      head_sha: string;
      status: "queued" | "in_progress" | "completed";
      conclusion:
        | "success"
        | "failure"
        | "neutral"
        | "cancelled"
        | "timed_out"
        | "action_required"
        | "stale"
        | null;
      url: string;
      before: string | null;
      after: string | null;
      /**
       * An array of pull requests that match this check suite. A pull request matches a check suite if they have the same `head_sha` and `head_branch`. When the check suite's `head_branch` is in a forked repository it will be `null` and the `pull_requests` array will be empty.
       */
      pull_requests: CheckRunPullRequest[];
      app: App;
      created_at: string;
      updated_at: string;
    };
    app: App;
    pull_requests: CheckRunPullRequest[];
    deployment?: CheckRunDeployment;
  };
  /**
   * The action requested by the user.
   */
  requested_action: {
    /**
     * The integrator reference of the action requested by the user.
     */
    identifier?: string;
  };
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface CheckRunRerequestedEvent {
  action: "rerequested";
  /**
   * The [check_run](https://docs.github.com/en/rest/reference/checks#get-a-check-run).
   */
  check_run: {
    /**
     * The id of the check.
     */
    id: number;
    node_id?: string;
    /**
     * The SHA of the commit that is being checked.
     */
    head_sha: string;
    external_id: string;
    url: string;
    html_url: string;
    details_url?: string;
    /**
     * The phase of the lifecycle that the check is currently in.
     */
    status: "completed";
    /**
     * The result of the completed check run. Can be one of `success`, `failure`, `neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has `completed`.
     */
    conclusion:
      | "success"
      | "failure"
      | "neutral"
      | "cancelled"
      | "timed_out"
      | "action_required"
      | "stale"
      | null;
    /**
     * The time that the check run began. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
     */
    started_at: string;
    /**
     * The time the check completed. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
     */
    completed_at: string;
    output: {
      title?: string | null;
      summary: string | null;
      text: string | null;
      annotations_count: number;
      annotations_url: string;
    };
    /**
     * The name of the check.
     */
    name: string;
    check_suite: {
      /**
       * The id of the check suite that this check run is part of.
       */
      id: number;
      node_id?: string;
      head_branch: string | null;
      /**
       * The SHA of the head commit that is being checked.
       */
      head_sha: string;
      status: "completed";
      conclusion:
        | "success"
        | "failure"
        | "neutral"
        | "cancelled"
        | "timed_out"
        | "action_required"
        | "stale";
      url: string;
      before: string | null;
      after: string | null;
      /**
       * An array of pull requests that match this check suite. A pull request matches a check suite if they have the same `head_sha` and `head_branch`. When the check suite's `head_branch` is in a forked repository it will be `null` and the `pull_requests` array will be empty.
       */
      pull_requests: CheckRunPullRequest[];
      app: App;
      created_at: string;
      updated_at: string;
    };
    app: App;
    pull_requests: CheckRunPullRequest[];
    deployment?: CheckRunDeployment;
  };
  /**
   * The action requested by the user.
   */
  requested_action?: {
    /**
     * The integrator reference of the action requested by the user.
     */
    identifier?: string;
  } | null;
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface CheckSuiteCompletedEvent {
  action: "completed";
  /**
   * The [check_suite](https://docs.github.com/en/rest/reference/checks#suites).
   */
  check_suite: {
    id: number;
    node_id: string;
    /**
     * The head branch name the changes are on.
     */
    head_branch: string | null;
    /**
     * The SHA of the head commit that is being checked.
     */
    head_sha: string;
    /**
     * The summary status for all check runs that are part of the check suite. Can be `requested`, `in_progress`, or `completed`.
     */
    status: "requested" | "in_progress" | "completed" | "queued" | null;
    /**
     * The summary conclusion for all check runs that are part of the check suite. Can be one of `success`, `failure`, `neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has `completed`.
     */
    conclusion:
      | "success"
      | "failure"
      | "neutral"
      | "cancelled"
      | "timed_out"
      | "action_required"
      | "stale"
      | null;
    /**
     * URL that points to the check suite API resource.
     */
    url: string;
    before: string;
    after: string;
    /**
     * An array of pull requests that match this check suite. A pull request matches a check suite if they have the same `head_sha` and `head_branch`. When the check suite's `head_branch` is in a forked repository it will be `null` and the `pull_requests` array will be empty.
     */
    pull_requests: CheckRunPullRequest[];
    app: App;
    created_at: string;
    updated_at: string;
    latest_check_runs_count: number;
    check_runs_url: string;
    head_commit: SimpleCommit;
  };
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface SimpleCommit {
  id: string;
  tree_id: string;
  message: string;
  timestamp: string;
  author: Committer;
  committer: Committer;
}
/**
 * Metaproperties for Git author/committer information.
 */
export interface Committer {
  /**
   * The git author's name.
   */
  name: string;
  /**
   * The git author's email address.
   */
  email: string;
  date?: string;
  username?: string;
}
export interface CheckSuiteRequestedEvent {
  action: "requested";
  /**
   * The [check_suite](https://docs.github.com/en/rest/reference/checks#suites).
   */
  check_suite: {
    id: number;
    node_id: string;
    /**
     * The head branch name the changes are on.
     */
    head_branch: string | null;
    /**
     * The SHA of the head commit that is being checked.
     */
    head_sha: string;
    /**
     * The summary status for all check runs that are part of the check suite. Can be `requested`, `in_progress`, or `completed`.
     */
    status: "requested" | "in_progress" | "completed" | "queued" | null;
    /**
     * The summary conclusion for all check runs that are part of the check suite. Can be one of `success`, `failure`,` neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has completed.
     */
    conclusion:
      | "success"
      | "failure"
      | "neutral"
      | "cancelled"
      | "timed_out"
      | "action_required"
      | "stale"
      | null;
    /**
     * URL that points to the check suite API resource.
     */
    url: string;
    before: string;
    after: string;
    /**
     * An array of pull requests that match this check suite. A pull request matches a check suite if they have the same `head_sha` and `head_branch`. When the check suite's `head_branch` is in a forked repository it will be `null` and the `pull_requests` array will be empty.
     */
    pull_requests: CheckRunPullRequest[];
    app: App;
    created_at: string;
    updated_at: string;
    latest_check_runs_count: number;
    check_runs_url: string;
    head_commit: SimpleCommit;
  };
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface CheckSuiteRerequestedEvent {
  action: "rerequested";
  /**
   * The [check_suite](https://docs.github.com/en/rest/reference/checks#suites).
   */
  check_suite: {
    id: number;
    node_id: string;
    /**
     * The head branch name the changes are on.
     */
    head_branch: string | null;
    /**
     * The SHA of the head commit that is being checked.
     */
    head_sha: string;
    /**
     * The summary status for all check runs that are part of the check suite. Can be `requested`, `in_progress`, or `completed`.
     */
    status: "requested" | "in_progress" | "completed" | "queued" | null;
    /**
     * The summary conclusion for all check runs that are part of the check suite. Can be one of `success`, `failure`,` neutral`, `cancelled`, `timed_out`, `action_required` or `stale`. This value will be `null` until the check run has completed.
     */
    conclusion:
      | "success"
      | "failure"
      | "neutral"
      | "cancelled"
      | "timed_out"
      | "action_required"
      | "stale"
      | null;
    /**
     * URL that points to the check suite API resource.
     */
    url: string;
    before: string;
    after: string;
    /**
     * An array of pull requests that match this check suite. A pull request matches a check suite if they have the same `head_sha` and `head_branch`. When the check suite's `head_branch` is in a forked repository it will be `null` and the `pull_requests` array will be empty.
     */
    pull_requests: CheckRunPullRequest[];
    app: App;
    created_at: string;
    updated_at: string;
    latest_check_runs_count: number;
    check_runs_url: string;
    head_commit: SimpleCommit;
  };
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface CodeScanningAlertAppearedInBranchEvent {
  action: "appeared_in_branch";
  /**
   * The code scanning alert involved in the event.
   */
  alert: {
    /**
     * The code scanning alert number.
     */
    number: number;
    /**
     * The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ.`
     */
    created_at: string;
    url: string;
    /**
     * The GitHub URL of the alert resource.
     */
    html_url: string;
    instances: AlertInstance[];
    /**
     * State of a code scanning alert.
     */
    state: "open" | "dismissed" | "fixed";
    dismissed_by: User | null;
    /**
     * The time that the alert was dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
     */
    dismissed_at: string | null;
    /**
     * The reason for dismissing or closing the alert. Can be one of: `false positive`, `won't fix`, and `used in tests`.
     */
    dismissed_reason: "false positive" | "won't fix" | "used in tests" | null;
    rule: {
      /**
       * A unique identifier for the rule used to detect the alert.
       */
      id: string;
      /**
       * The severity of the alert.
       */
      severity: "none" | "note" | "warning" | "error" | null;
      /**
       * A short description of the rule used to detect the alert.
       */
      description: string;
    };
    tool: {
      /**
       * The name of the tool used to generate the code scanning analysis alert.
       */
      name: string;
      /**
       * The version of the tool used to detect the alert.
       */
      version: string | null;
    };
  };
  /**
   * The Git reference of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty.
   */
  ref: string;
  /**
   * The commit SHA of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty.
   */
  commit_oid: string;
  repository: Repository;
  sender: GitHubOrg;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface AlertInstance {
  /**
   * The full Git reference, formatted as `refs/heads/<branch name>`.
   */
  ref: string;
  /**
   * Identifies the configuration under which the analysis was executed. For example, in GitHub Actions this includes the workflow filename and job name.
   */
  analysis_key: string;
  /**
   * Identifies the variable values associated with the environment in which the analysis that generated this alert instance was performed, such as the language that was analyzed.
   */
  environment: string;
  /**
   * State of a code scanning alert.
   */
  state: "open" | "dismissed" | "fixed";
  commit_sha?: string;
  message?: {
    text?: string;
  };
  location?: {
    path?: string;
    start_line?: number;
    end_line?: number;
    start_column?: number;
    end_column?: number;
  };
  classifications?: string[];
}
export interface GitHubOrg {
  login: "github";
  id: 9919;
  node_id: "MDEyOk9yZ2FuaXphdGlvbjk5MTk=";
  name?: "GitHub";
  email?: null;
  avatar_url: "https://avatars.githubusercontent.com/u/9919?v=4";
  gravatar_id: string;
  url: "https://api.github.com/users/github";
  html_url: "https://github.com/github";
  followers_url: "https://api.github.com/users/github/followers";
  following_url: "https://api.github.com/users/github/following{/other_user}";
  gists_url: "https://api.github.com/users/github/gists{/gist_id}";
  starred_url: "https://api.github.com/users/github/starred{/owner}{/repo}";
  subscriptions_url: "https://api.github.com/users/github/subscriptions";
  organizations_url: "https://api.github.com/users/github/orgs";
  repos_url: "https://api.github.com/users/github/repos";
  events_url: "https://api.github.com/users/github/events{/privacy}";
  received_events_url: "https://api.github.com/users/github/received_events";
  type: "Organization";
  site_admin: boolean;
}
export interface CodeScanningAlertClosedByUserEvent {
  action: "closed_by_user";
  /**
   * The code scanning alert involved in the event.
   */
  alert: {
    /**
     * The code scanning alert number.
     */
    number: number;
    /**
     * The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ.`
     */
    created_at: string;
    url: string;
    /**
     * The GitHub URL of the alert resource.
     */
    html_url: string;
    instances: (AlertInstance & {
      state: "dismissed";
    })[];
    /**
     * State of a code scanning alert.
     */
    state: "dismissed";
    dismissed_by: User;
    /**
     * The time that the alert was dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
     */
    dismissed_at: string;
    /**
     * The reason for dismissing or closing the alert. Can be one of: `false positive`, `won't fix`, and `used in tests`.
     */
    dismissed_reason: "false positive" | "won't fix" | "used in tests" | null;
    rule: {
      /**
       * A unique identifier for the rule used to detect the alert.
       */
      id: string;
      /**
       * The severity of the alert.
       */
      severity: "none" | "note" | "warning" | "error" | null;
      /**
       * A short description of the rule used to detect the alert.
       */
      description: string;
      name?: string;
      full_description?: string;
      tags?: null;
      help?: null;
    };
    tool: {
      /**
       * The name of the tool used to generate the code scanning analysis alert.
       */
      name: string;
      /**
       * The version of the tool used to detect the alert.
       */
      version: string | null;
      guid?: string | null;
    };
  };
  /**
   * The Git reference of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty.
   */
  ref: string;
  /**
   * The commit SHA of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty.
   */
  commit_oid: string;
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface CodeScanningAlertCreatedEvent {
  action: "created";
  /**
   * The code scanning alert involved in the event.
   */
  alert: {
    /**
     * The code scanning alert number.
     */
    number: number;
    /**
     * The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ.`
     */
    created_at: string;
    url: string;
    /**
     * The GitHub URL of the alert resource.
     */
    html_url: string;
    instances: (AlertInstance & {
      state: "open" | "dismissed";
    })[];
    /**
     * State of a code scanning alert.
     */
    state: "open" | "dismissed";
    dismissed_by: null;
    /**
     * The time that the alert was dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
     */
    dismissed_at: null;
    /**
     * The reason for dismissing or closing the alert. Can be one of: `false positive`, `won't fix`, and `used in tests`.
     */
    dismissed_reason: null;
    rule: {
      /**
       * A unique identifier for the rule used to detect the alert.
       */
      id: string;
      /**
       * The severity of the alert.
       */
      severity: "none" | "note" | "warning" | "error" | null;
      /**
       * A short description of the rule used to detect the alert.
       */
      description: string;
      name?: string;
      full_description?: string;
      tags?: null;
      help?: null;
    };
    tool: {
      /**
       * The name of the tool used to generate the code scanning analysis alert.
       */
      name: string;
      /**
       * The version of the tool used to detect the alert.
       */
      version: string | null;
      guid?: string | null;
    };
  };
  /**
   * The Git reference of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty.
   */
  ref: string;
  /**
   * The commit SHA of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty.
   */
  commit_oid: string;
  repository: Repository;
  sender: GitHubOrg;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface CodeScanningAlertFixedEvent {
  action: "fixed";
  /**
   * The code scanning alert involved in the event.
   */
  alert: {
    /**
     * The code scanning alert number.
     */
    number: number;
    /**
     * The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ.`
     */
    created_at: string;
    url: string;
    /**
     * The GitHub URL of the alert resource.
     */
    html_url: string;
    instances: (AlertInstance & {
      state: "fixed";
    })[];
    /**
     * State of a code scanning alert.
     */
    state: "fixed";
    dismissed_by: User | null;
    /**
     * The time that the alert was dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
     */
    dismissed_at: string | null;
    /**
     * The reason for dismissing or closing the alert. Can be one of: `false positive`, `won't fix`, and `used in tests`.
     */
    dismissed_reason: "false positive" | "won't fix" | "used in tests" | null;
    rule: {
      /**
       * A unique identifier for the rule used to detect the alert.
       */
      id: string;
      /**
       * The severity of the alert.
       */
      severity: "none" | "note" | "warning" | "error" | null;
      /**
       * A short description of the rule used to detect the alert.
       */
      description: string;
      name?: string;
      full_description?: string;
      tags?: null;
      help?: null;
    };
    tool: {
      /**
       * The name of the tool used to generate the code scanning analysis alert.
       */
      name: string;
      /**
       * The version of the tool used to detect the alert.
       */
      version: string | null;
      guid?: string | null;
    };
    most_recent_instance?: AlertInstance;
    instances_url?: string;
  };
  /**
   * The Git reference of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty.
   */
  ref: string;
  /**
   * The commit SHA of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty.
   */
  commit_oid: string;
  repository: Repository;
  sender: GitHubOrg;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface CodeScanningAlertReopenedEvent {
  action: "reopened";
  /**
   * The code scanning alert involved in the event.
   */
  alert: {
    /**
     * The code scanning alert number.
     */
    number: number;
    /**
     * The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ.`
     */
    created_at: string;
    url: string;
    /**
     * The GitHub URL of the alert resource.
     */
    html_url: string;
    instances: (AlertInstance & {
      state: "open";
    })[];
    /**
     * State of a code scanning alert.
     */
    state: "open" | "dismissed" | "fixed";
    dismissed_by: null;
    /**
     * The time that the alert was dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
     */
    dismissed_at: null;
    /**
     * The reason for dismissing or closing the alert. Can be one of: `false positive`, `won't fix`, and `used in tests`.
     */
    dismissed_reason: null;
    rule: {
      /**
       * A unique identifier for the rule used to detect the alert.
       */
      id: string;
      /**
       * The severity of the alert.
       */
      severity: "none" | "note" | "warning" | "error" | null;
      /**
       * A short description of the rule used to detect the alert.
       */
      description: string;
      name?: string;
      full_description?: string;
      tags?: null;
      help?: null;
    };
    tool: {
      /**
       * The name of the tool used to generate the code scanning analysis alert.
       */
      name: string;
      /**
       * The version of the tool used to detect the alert.
       */
      version: string | null;
      guid?: string | null;
    };
  };
  /**
   * The Git reference of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty.
   */
  ref: string;
  /**
   * The commit SHA of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty.
   */
  commit_oid: string;
  repository: Repository;
  sender: GitHubOrg;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface CodeScanningAlertReopenedByUserEvent {
  action: "reopened_by_user";
  /**
   * The code scanning alert involved in the event.
   */
  alert: {
    /**
     * The code scanning alert number.
     */
    number: number;
    /**
     * The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ.`
     */
    created_at: string;
    url: string;
    /**
     * The GitHub URL of the alert resource.
     */
    html_url: string;
    instances: (AlertInstance & {
      state: "open";
    })[];
    /**
     * State of a code scanning alert.
     */
    state: "open";
    dismissed_by: null;
    /**
     * The time that the alert was dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
     */
    dismissed_at: null;
    /**
     * The reason for dismissing or closing the alert. Can be one of: `false positive`, `won't fix`, and `used in tests`.
     */
    dismissed_reason: null;
    rule: {
      /**
       * A unique identifier for the rule used to detect the alert.
       */
      id: string;
      /**
       * The severity of the alert.
       */
      severity: "none" | "note" | "warning" | "error" | null;
      /**
       * A short description of the rule used to detect the alert.
       */
      description: string;
    };
    tool: {
      /**
       * The name of the tool used to generate the code scanning analysis alert.
       */
      name: string;
      /**
       * The version of the tool used to detect the alert.
       */
      version: string | null;
    };
  };
  /**
   * The Git reference of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty.
   */
  ref: string;
  /**
   * The commit SHA of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty.
   */
  commit_oid: string;
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
/**
 * A commit comment is created. The type of activity is specified in the `action` property.
 */
export interface CommitCommentCreatedEvent {
  /**
   * The action performed. Can be `created`.
   */
  action: "created";
  /**
   * The [commit comment](https://docs.github.com/en/rest/reference/repos#get-a-commit-comment) resource.
   */
  comment: {
    url: string;
    html_url: string;
    /**
     * The ID of the commit comment.
     */
    id: number;
    /**
     * The node ID of the commit comment.
     */
    node_id: string;
    user: User;
    /**
     * The line index in the diff to which the comment applies.
     */
    position: number | null;
    /**
     * The line of the blob to which the comment applies. The last line of the range for a multi-line comment
     */
    line: number | null;
    /**
     * The relative path of the file to which the comment applies.
     */
    path: string | null;
    /**
     * The SHA of the commit to which the comment applies.
     */
    commit_id: string;
    created_at: string;
    updated_at: string;
    author_association: AuthorAssociation;
    /**
     * The text of the comment.
     */
    body: string;
  };
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface ContentReferenceCreatedEvent {
  action: "created";
  content_reference: {
    id: number;
    node_id: string;
    reference: string;
  };
  repository: Repository;
  sender: User;
  installation: InstallationLite;
  organization?: Organization;
}
/**
 * A Git branch or tag is created.
 */
export interface CreateEvent {
  /**
   * The [`git ref`](https://docs.github.com/en/rest/reference/git#get-a-reference) resource.
   */
  ref: string;
  /**
   * The type of Git ref object created in the repository. Can be either `branch` or `tag`.
   */
  ref_type: "tag" | "branch";
  /**
   * The name of the repository's default branch (usually `main`).
   */
  master_branch: string;
  /**
   * The repository's current description.
   */
  description: string | null;
  /**
   * The pusher type for the event. Can be either `user` or a deploy key.
   */
  pusher_type: string;
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
/**
 * A Git branch or tag is deleted.
 */
export interface DeleteEvent {
  /**
   * The [`git ref`](https://docs.github.com/en/rest/reference/git#get-a-reference) resource.
   */
  ref: string;
  /**
   * The type of Git ref object deleted in the repository. Can be either `branch` or `tag`.
   */
  ref_type: "tag" | "branch";
  /**
   * The pusher type for the event. Can be either `user` or a deploy key.
   */
  pusher_type: string;
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface DeployKeyCreatedEvent {
  action: "created";
  /**
   * The [`deploy key`](https://docs.github.com/en/rest/reference/repos#get-a-deploy-key) resource.
   */
  key: {
    id: number;
    key: string;
    url: string;
    title: string;
    verified: boolean;
    created_at: string;
    read_only: boolean;
  };
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface DeployKeyDeletedEvent {
  action: "deleted";
  /**
   * The [`deploy key`](https://docs.github.com/en/rest/reference/repos#get-a-deploy-key) resource.
   */
  key: {
    id: number;
    key: string;
    url: string;
    title: string;
    verified: boolean;
    created_at: string;
    read_only: boolean;
  };
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface DeploymentCreatedEvent {
  action: "created";
  /**
   * The [deployment](https://docs.github.com/en/rest/reference/repos#list-deployments).
   */
  deployment: {
    url: string;
    id: number;
    node_id: string;
    sha: string;
    ref: string;
    task: string;
    payload: {};
    original_environment: string;
    environment: string;
    description: null;
    creator: User;
    created_at: string;
    updated_at: string;
    statuses_url: string;
    repository_url: string;
    performed_via_github_app?: App | null;
  };
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface DeploymentStatusCreatedEvent {
  action: "created";
  /**
   * The [deployment status](https://docs.github.com/en/rest/reference/repos#list-deployment-statuses).
   */
  deployment_status: {
    url: string;
    id: number;
    node_id: string;
    /**
     * The new state. Can be `pending`, `success`, `failure`, or `error`.
     */
    state: string;
    creator: User;
    /**
     * The optional human-readable description added to the status.
     */
    description: string;
    environment: string;
    /**
     * The optional link added to the status.
     */
    target_url: string;
    created_at: string;
    updated_at: string;
    deployment_url: string;
    repository_url: string;
    performed_via_github_app?: App | null;
  };
  /**
   * The [deployment](https://docs.github.com/en/rest/reference/repos#list-deployments) that this status is associated with.
   */
  deployment: {
    url: string;
    id: number;
    node_id: string;
    sha: string;
    ref: string;
    task: string;
    payload: {};
    original_environment: string;
    environment: string;
    description: null;
    creator: User;
    created_at: string;
    updated_at: string;
    statuses_url: string;
    repository_url: string;
  };
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface DiscussionAnsweredEvent {
  action: "answered";
  discussion: Discussion & {
    category: {
      is_answerable: true;
    };
    answer_html_url: string;
    answer_chosen_at: string;
    answer_chosen_by: User;
  };
  answer: {
    id: number;
    node_id: string;
    html_url: string;
    parent_id: null;
    child_comment_count: number;
    repository_url: string;
    discussion_id: number;
    author_association: AuthorAssociation;
    user: User;
    created_at: string;
    updated_at: string;
    body: string;
  };
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface Discussion {
  repository_url: string;
  category: {
    id: number;
    repository_id: number;
    emoji: string;
    name: string;
    description: string;
    created_at: string;
    updated_at: string;
    slug: string;
    is_answerable: boolean;
  };
  answer_html_url: string | null;
  answer_chosen_at: string | null;
  answer_chosen_by: User | null;
  html_url: string;
  id: number;
  node_id: string;
  number: number;
  title: string;
  user: User;
  state: "open" | "locked";
  locked: boolean;
  comments: number;
  created_at: string;
  updated_at: string;
  author_association: AuthorAssociation;
  active_lock_reason: string | null;
  body: string;
}
export interface DiscussionCategoryChangedEvent {
  changes: {
    category: {
      from: {
        id: number;
        repository_id: number;
        emoji: string;
        name: string;
        description: string;
        created_at: string;
        updated_at: string;
        slug: string;
        is_answerable: boolean;
      };
    };
  };
  action: "category_changed";
  discussion: Discussion;
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface DiscussionCreatedEvent {
  action: "created";
  discussion: Discussion & {
    state: "open";
    locked: false;
    answer_html_url: null;
    answer_chosen_at: null;
    answer_chosen_by: null;
  };
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface DiscussionDeletedEvent {
  action: "deleted";
  discussion: Discussion;
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface DiscussionEditedEvent {
  changes?: {
    title?: {
      from: string;
    };
    body?: {
      from: string;
    };
  };
  action: "edited";
  discussion: Discussion;
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface DiscussionLockedEvent {
  action: "locked";
  discussion: Discussion & {
    state: "locked";
    locked: true;
  };
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface DiscussionPinnedEvent {
  action: "pinned";
  discussion: Discussion;
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface DiscussionTransferredEvent {
  changes: {
    new_discussion: Discussion;
    new_repository: Repository;
  };
  action: "transferred";
  discussion: Discussion;
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface DiscussionUnansweredEvent {
  action: "unanswered";
  discussion: Discussion & {
    category: {
      is_answerable: true;
    };
    answer_html_url: null;
    answer_chosen_at: null;
    answer_chosen_by: null;
  };
  old_answer: {
    id: number;
    node_id: string;
    html_url: string;
    parent_id: null;
    child_comment_count: number;
    repository_url: string;
    discussion_id: number;
    author_association: AuthorAssociation;
    user: User;
    created_at: string;
    updated_at: string;
    body: string;
  };
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface DiscussionUnlockedEvent {
  action: "unlocked";
  discussion: Discussion & {
    state: "open";
    locked: false;
  };
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface DiscussionUnpinnedEvent {
  action: "unpinned";
  discussion: Discussion;
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface DiscussionCommentCreatedEvent {
  action: "created";
  comment: {
    id: number;
    node_id: string;
    html_url: string;
    parent_id: number | null;
    child_comment_count: number;
    repository_url: string;
    discussion_id: number;
    author_association: AuthorAssociation;
    user: User;
    created_at: string;
    updated_at: string;
    body: string;
  };
  discussion: Discussion;
  repository: Repository;
  sender: User;
  installation: InstallationLite;
  organization?: Organization;
}
export interface DiscussionCommentDeletedEvent {
  action: "deleted";
  comment: {
    id: number;
    node_id: string;
    html_url: string;
    parent_id: number | null;
    child_comment_count: number;
    repository_url: string;
    discussion_id: number;
    author_association: AuthorAssociation;
    user: User;
    created_at: string;
    updated_at: string;
    body: string;
  };
  discussion: Discussion;
  repository: Repository;
  sender: User;
  installation: InstallationLite;
  organization?: Organization;
}
export interface DiscussionCommentEditedEvent {
  changes: {
    body: {
      from: string;
    };
  };
  action: "edited";
  comment: {
    id: number;
    node_id: string;
    html_url: string;
    parent_id: number | null;
    child_comment_count: number;
    repository_url: string;
    discussion_id: number;
    author_association: AuthorAssociation;
    user: User;
    created_at: string;
    updated_at: string;
    body: string;
  };
  discussion: Discussion;
  repository: Repository;
  sender: User;
  installation: InstallationLite;
  organization?: Organization;
}
/**
 * A user forks a repository.
 */
export interface ForkEvent {
  /**
   * The created [`repository`](https://docs.github.com/en/rest/reference/repos#get-a-repository) resource.
   */
  forkee: Repository & {
    fork?: true;
  };
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface GithubAppAuthorizationRevokedEvent {
  action: "revoked";
  sender: User;
}
/**
 * A wiki page is created or updated.
 */
export interface GollumEvent {
  /**
   * The pages that were updated.
   */
  pages: {
    /**
     * The name of the page.
     */
    page_name: string;
    /**
     * The current page title.
     */
    title: string;
    summary: null;
    /**
     * The action that was performed on the page. Can be `created` or `edited`.
     */
    action: "created" | "edited";
    /**
     * The latest commit SHA of the page.
     */
    sha: string;
    /**
     * Points to the HTML wiki page.
     */
    html_url: string;
  }[];
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface InstallationCreatedEvent {
  action: "created";
  installation: Installation;
  /**
   * An array of repository objects that the installation can access.
   */
  repositories?: {
    /**
     * Unique identifier of the repository
     */
    id: number;
    node_id: string;
    /**
     * The name of the repository.
     */
    name: string;
    full_name: string;
    /**
     * Whether the repository is private or public.
     */
    private: boolean;
  }[];
  requester?: User;
  sender: User;
}
/**
 * The GitHub App installation.
 */
export interface Installation {
  /**
   * The ID of the installation.
   */
  id: number;
  account: User;
  /**
   * Describe whether all repositories have been selected or there's a selection involved
   */
  repository_selection: "all" | "selected";
  access_tokens_url: string;
  repositories_url: string;
  html_url: string;
  app_id: number;
  app_slug?: string;
  /**
   * The ID of the user or organization this token is being scoped to.
   */
  target_id: number;
  target_type: "User" | "Organization";
  permissions: {
    actions?: "read" | "write";
    administration?: "read" | "write";
    checks?: "read" | "write";
    contents?: "read" | "write";
    deployments?: "read" | "write";
    issues?: "read" | "write";
    organization_administration?: "read" | "write";
    pages?: "read" | "write";
    pull_requests?: "read" | "write";
    repository_hooks?: "read" | "write";
    repository_projects?: "read" | "write";
    statuses?: "read" | "write";
    metadata?: "read" | "write";
    vulnerability_alerts?: "read" | "write";
  };
  events: string[];
  created_at: string | number;
  updated_at: string | number;
  single_file_name: string | null;
  has_multiple_single_files?: boolean;
  single_file_paths?: string[];
  suspended_by?: string | null;
  suspended_at?: string | null;
}
export interface InstallationDeletedEvent {
  action: "deleted";
  installation: Installation;
  /**
   * An array of repository objects that the installation can access.
   */
  repositories?: {
    /**
     * Unique identifier of the repository
     */
    id: number;
    node_id: string;
    /**
     * The name of the repository.
     */
    name: string;
    full_name: string;
    /**
     * Whether the repository is private or public.
     */
    private: boolean;
  }[];
  requester?: null;
  sender: User;
}
export interface InstallationNewPermissionsAcceptedEvent {
  action: "new_permissions_accepted";
  installation: Installation;
  /**
   * An array of repository objects that the installation can access.
   */
  repositories?: {
    /**
     * Unique identifier of the repository
     */
    id: number;
    node_id: string;
    /**
     * The name of the repository.
     */
    name: string;
    full_name: string;
    /**
     * Whether the repository is private or public.
     */
    private: boolean;
  }[];
  requester?: null;
  sender: User;
}
export interface InstallationSuspendEvent {
  action: "suspend";
  installation: Installation;
  /**
   * An array of repository objects that the installation can access.
   */
  repositories?: {
    /**
     * Unique identifier of the repository
     */
    id: number;
    node_id: string;
    /**
     * The name of the repository.
     */
    name: string;
    full_name: string;
    /**
     * Whether the repository is private or public.
     */
    private: boolean;
  }[];
  requester?: null;
  sender: User;
}
export interface InstallationUnsuspendEvent {
  action: "unsuspend";
  installation: Installation;
  /**
   * An array of repository objects that the installation can access.
   */
  repositories?: {
    /**
     * Unique identifier of the repository
     */
    id: number;
    node_id: string;
    /**
     * The name of the repository.
     */
    name: string;
    full_name: string;
    /**
     * Whether the repository is private or public.
     */
    private: boolean;
  }[];
  requester?: null;
  sender: User;
}
export interface InstallationRepositoriesAddedEvent {
  action: "added";
  installation: Installation;
  /**
   * Describe whether all repositories have been selected or there's a selection involved
   */
  repository_selection: "all" | "selected";
  /**
   * An array of repository objects, which were added to the installation.
   */
  repositories_added: {
    /**
     * Unique identifier of the repository
     */
    id: number;
    node_id: string;
    /**
     * The name of the repository.
     */
    name: string;
    full_name: string;
    /**
     * Whether the repository is private or public.
     */
    private: boolean;
  }[];
  /**
   * An array of repository objects, which were removed from the installation.
   */
  repositories_removed: [];
  requester?: User;
  sender: User;
}
export interface InstallationRepositoriesRemovedEvent {
  action: "removed";
  installation: Installation;
  /**
   * Describe whether all repositories have been selected or there's a selection involved
   */
  repository_selection: "all" | "selected";
  /**
   * An array of repository objects, which were added to the installation.
   */
  repositories_added: [];
  /**
   * An array of repository objects, which were removed from the installation.
   */
  repositories_removed: {
    /**
     * Unique identifier of the repository
     */
    id: number;
    node_id: string;
    /**
     * The name of the repository.
     */
    name: string;
    full_name: string;
    /**
     * Whether the repository is private or public.
     */
    private: boolean;
  }[];
  sender: User;
}
export interface IssueCommentCreatedEvent {
  action: "created";
  /**
   * The [issue](https://docs.github.com/en/rest/reference/issues) the comment belongs to.
   */
  issue: Issue & {
    assignee: User | null;
    /**
     * State of the issue; either 'open' or 'closed'
     */
    state: "open" | "closed";
    closed_at: null;
    locked: boolean;
    labels: Label[];
    pull_request?: {
      url: string;
      html_url: string;
      diff_url: string;
      patch_url: string;
    };
  };
  /**
   * The [comment](https://docs.github.com/en/rest/reference/issues#comments) itself.
   */
  comment: {
    /**
     * URL for the issue comment
     */
    url: string;
    html_url: string;
    issue_url: string;
    /**
     * Unique identifier of the issue comment
     */
    id: number;
    node_id: string;
    user: User;
    created_at: string;
    updated_at: string;
    author_association: AuthorAssociation;
    /**
     * Contents of the issue comment
     */
    body: string;
    performed_via_github_app?: App | null;
  };
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface Issue {
  /**
   * URL for the issue
   */
  url: string;
  repository_url: string;
  labels_url: string;
  comments_url: string;
  events_url: string;
  html_url: string;
  id: number;
  node_id: string;
  number: number;
  /**
   * Title of the issue
   */
  title: string;
  user: User;
  labels?: Label[];
  /**
   * State of the issue; either 'open' or 'closed'
   */
  state?: "open" | "closed";
  locked?: boolean;
  assignee?: User | null;
  assignees: User[];
  milestone: Milestone | null;
  comments: number;
  created_at: string;
  updated_at: string;
  closed_at: string | null;
  author_association: AuthorAssociation;
  active_lock_reason: "resolved" | "off-topic" | "too heated" | "spam" | null;
  performed_via_github_app?: App | null;
  pull_request?: {
    url?: string;
    html_url?: string;
    diff_url?: string;
    patch_url?: string;
  };
  /**
   * Contents of the issue
   */
  body: string;
}
export interface Label {
  id: number;
  node_id: string;
  /**
   * URL for the label
   */
  url: string;
  /**
   * The name of the label.
   */
  name: string;
  description: string | null;
  /**
   * 6-character hex code, without the leading #, identifying the color
   */
  color: string;
  default: boolean;
}
/**
 * A collection of related issues and pull requests.
 */
export interface Milestone {
  url: string;
  html_url: string;
  labels_url: string;
  id: number;
  node_id: string;
  /**
   * The number of the milestone.
   */
  number: number;
  /**
   * The title of the milestone.
   */
  title: string;
  description: string | null;
  creator: User;
  open_issues: number;
  closed_issues: number;
  /**
   * The state of the milestone.
   */
  state: "open" | "closed";
  created_at: string;
  updated_at: string;
  due_on: string | null;
  closed_at: string | null;
}
export interface IssueCommentDeletedEvent {
  action: "deleted";
  /**
   * The [issue](https://docs.github.com/en/rest/reference/issues) the comment belongs to.
   */
  issue: Issue & {
    assignee: User | null;
    /**
     * State of the issue; either 'open' or 'closed'
     */
    state: "open" | "closed";
    closed_at: null;
    locked: boolean;
    labels: Label[];
    pull_request?: {
      url: string;
      html_url: string;
      diff_url: string;
      patch_url: string;
    };
  };
  /**
   * The [comment](https://docs.github.com/en/rest/reference/issues#comments) itself.
   */
  comment: {
    /**
     * URL for the issue comment
     */
    url: string;
    html_url: string;
    issue_url: string;
    /**
     * Unique identifier of the issue comment
     */
    id: number;
    node_id: string;
    user: User;
    created_at: string;
    updated_at: string;
    author_association: AuthorAssociation;
    /**
     * Contents of the issue comment
     */
    body: string;
  };
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface IssueCommentEditedEvent {
  action: "edited";
  /**
   * The changes to the comment.
   */
  changes: {
    body?: {
      /**
       * The previous version of the body.
       */
      from: string;
    };
  };
  /**
   * The [issue](https://docs.github.com/en/rest/reference/issues) the comment belongs to.
   */
  issue: Issue & {
    assignee: User | null;
    /**
     * State of the issue; either 'open' or 'closed'
     */
    state: "open" | "closed";
    locked: boolean;
    labels: Label[];
    pull_request?: {
      url: string;
      html_url: string;
      diff_url: string;
      patch_url: string;
    };
  };
  /**
   * The [comment](https://docs.github.com/en/rest/reference/issues#comments) itself.
   */
  comment: {
    /**
     * URL for the issue comment
     */
    url: string;
    html_url: string;
    issue_url: string;
    /**
     * Unique identifier of the issue comment
     */
    id: number;
    node_id: string;
    user: User;
    created_at: string;
    updated_at: string;
    author_association: AuthorAssociation;
    /**
     * Contents of the issue comment
     */
    body: string;
  };
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
/**
 * Activity related to an issue. The type of activity is specified in the action property.
 */
export interface IssuesAssignedEvent {
  /**
   * The action that was performed.
   */
  action: "assigned";
  issue: Issue;
  /**
   * The optional user who was assigned or unassigned from the issue.
   */
  assignee?: User | null;
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface IssuesClosedEvent {
  /**
   * The action that was performed.
   */
  action: "closed";
  /**
   * The [issue](https://docs.github.com/en/rest/reference/issues) itself.
   */
  issue: Issue & {
    state: "closed";
    closed_at: string;
  };
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface IssuesDeletedEvent {
  action: "deleted";
  issue: Issue;
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface IssuesDemilestonedEvent {
  action: "demilestoned";
  issue: Issue;
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface IssuesEditedEvent {
  action: "edited";
  issue: Issue;
  label?: Label;
  /**
   * The changes to the issue.
   */
  changes: {
    body?: {
      /**
       * The previous version of the body.
       */
      from: string;
    };
    title?: {
      /**
       * The previous version of the title.
       */
      from: string;
    };
  };
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface IssuesLabeledEvent {
  action: "labeled";
  issue: Issue;
  label?: Label;
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface IssuesLockedEvent {
  action: "locked";
  issue: Issue & {
    locked: true;
    active_lock_reason: "resolved" | "off-topic" | "too heated" | "spam";
  };
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface IssuesMilestonedEvent {
  action: "milestoned";
  issue: Issue;
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface IssuesOpenedEvent {
  action: "opened";
  issue: Issue & {
    state: "open";
    closed_at: null;
  };
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface IssuesPinnedEvent {
  action: "pinned";
  issue: Issue;
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface IssuesReopenedEvent {
  action: "reopened";
  issue: Issue & {
    state: "open";
  };
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface IssuesTransferredEvent {
  action: "transferred";
  issue: Issue;
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface IssuesUnassignedEvent {
  /**
   * The action that was performed.
   */
  action: "unassigned";
  issue: Issue;
  /**
   * The optional user who was assigned or unassigned from the issue.
   */
  assignee?: User | null;
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface IssuesUnlabeledEvent {
  action: "unlabeled";
  issue: Issue;
  label?: Label;
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface IssuesUnlockedEvent {
  action: "unlocked";
  issue: Issue & {
    locked: false;
    active_lock_reason: null;
  };
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface IssuesUnpinnedEvent {
  action: "unpinned";
  issue: Issue;
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface LabelCreatedEvent {
  action: "created";
  label: Label;
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface LabelDeletedEvent {
  action: "deleted";
  label: Label;
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface LabelEditedEvent {
  action: "edited";
  label: Label;
  /**
   * The changes to the label if the action was `edited`.
   */
  changes?: {
    color?: {
      /**
       * The previous version of the color if the action was `edited`.
       */
      from: string;
    };
    name?: {
      /**
       * The previous version of the name if the action was `edited`.
       */
      from: string;
    };
  };
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface MarketplacePurchaseCancelledEvent {
  action: "cancelled";
  effective_date: string;
  sender: {
    login: string;
    id: number;
    avatar_url: string;
    gravatar_id: string;
    url: string;
    html_url: string;
    followers_url: string;
    following_url: string;
    gists_url: string;
    starred_url: string;
    subscriptions_url: string;
    organizations_url: string;
    repos_url: string;
    events_url: string;
    received_events_url: string;
    type: string;
    site_admin: boolean;
    email: string;
  };
  marketplace_purchase: MarketplacePurchase & {
    next_billing_date: string;
  };
  previous_marketplace_purchase?: MarketplacePurchase;
}
export interface MarketplacePurchase {
  account: {
    type: string;
    id: number;
    login: string;
    organization_billing_email: string;
  };
  billing_cycle: string;
  unit_count: number;
  on_free_trial: boolean;
  free_trial_ends_on: null;
  next_billing_date?: string;
  plan: {
    id: number;
    name: string;
    description: string;
    monthly_price_in_cents: number;
    yearly_price_in_cents: number;
    price_model: string;
    has_free_trial: boolean;
    unit_name: string | null;
    bullets: string[];
  };
}
export interface MarketplacePurchaseChangedEvent {
  action: "changed";
  effective_date: string;
  sender: {
    login: string;
    id: number;
    avatar_url: string;
    gravatar_id: string;
    url: string;
    html_url: string;
    followers_url: string;
    following_url: string;
    gists_url: string;
    starred_url: string;
    subscriptions_url: string;
    organizations_url: string;
    repos_url: string;
    events_url: string;
    received_events_url: string;
    type: string;
    site_admin: boolean;
    email: string;
  };
  marketplace_purchase: MarketplacePurchase & {
    next_billing_date: string;
  };
  previous_marketplace_purchase?: MarketplacePurchase;
}
export interface MarketplacePurchasePendingChangeEvent {
  action: "pending_change";
  effective_date: string;
  sender: {
    login: string;
    id: number;
    avatar_url: string;
    gravatar_id: string;
    url: string;
    html_url: string;
    followers_url: string;
    following_url: string;
    gists_url: string;
    starred_url: string;
    subscriptions_url: string;
    organizations_url: string;
    repos_url: string;
    events_url: string;
    received_events_url: string;
    type: string;
    site_admin: boolean;
    email: string;
  };
  marketplace_purchase: MarketplacePurchase & {
    next_billing_date: string;
  };
  previous_marketplace_purchase?: MarketplacePurchase;
}
export interface MarketplacePurchasePendingChangeCancelledEvent {
  action: "pending_change_cancelled";
  effective_date: string;
  sender: {
    login: string;
    id: number;
    avatar_url: string;
    gravatar_id: string;
    url: string;
    html_url: string;
    followers_url: string;
    following_url: string;
    gists_url: string;
    starred_url: string;
    subscriptions_url: string;
    organizations_url: string;
    repos_url: string;
    events_url: string;
    received_events_url: string;
    type: string;
    site_admin: boolean;
    email: string;
  };
  marketplace_purchase: MarketplacePurchase & {
    next_billing_date: string;
  };
  previous_marketplace_purchase?: MarketplacePurchase;
}
export interface MarketplacePurchasePurchasedEvent {
  action: "purchased";
  effective_date: string;
  sender: {
    login: string;
    id: number;
    avatar_url: string;
    gravatar_id: string;
    url: string;
    html_url: string;
    followers_url: string;
    following_url: string;
    gists_url: string;
    starred_url: string;
    subscriptions_url: string;
    organizations_url: string;
    repos_url: string;
    events_url: string;
    received_events_url: string;
    type: string;
    site_admin: boolean;
    email: string;
  };
  marketplace_purchase: MarketplacePurchase & {
    next_billing_date: string;
  };
  previous_marketplace_purchase?: MarketplacePurchase;
}
/**
 * Activity related to repository collaborators. The type of activity is specified in the action property.
 */
export interface MemberAddedEvent {
  action: "added";
  member: User;
  repository: Repository;
  installation?: InstallationLite;
  sender: User;
}
export interface MemberEditedEvent {
  action: "edited";
  member: User;
  /**
   * The changes to the collaborator permissions
   */
  changes: {
    old_permission: {
      /**
       * The previous permissions of the collaborator if the action was edited.
       */
      from: string;
    };
  };
  repository: Repository;
  installation?: InstallationLite;
  sender: User;
}
export interface MemberRemovedEvent {
  action: "removed";
  member: User;
  repository: Repository;
  installation?: InstallationLite;
  sender: User;
}
export interface MembershipAddedEvent {
  action: "added";
  /**
   * The scope of the membership. Currently, can only be `team`.
   */
  scope: "team";
  member: User;
  sender: User;
  team: Team;
  organization: Organization;
  installation?: InstallationLite;
}
/**
 * Groups of organization members that gives permissions on specified repositories.
 */
export interface Team {
  /**
   * Name of the team
   */
  name: string;
  /**
   * Unique identifier of the team
   */
  id: number;
  node_id: string;
  slug: string;
  /**
   * Description of the team
   */
  description: string | null;
  privacy: "open" | "closed" | "secret";
  /**
   * URL for the team
   */
  url: string;
  html_url: string;
  members_url: string;
  repositories_url: string;
  /**
   * Permission that the team will have for its repositories
   */
  permission: string;
  parent?: {
    /**
     * Name of the team
     */
    name: string;
    /**
     * Unique identifier of the team
     */
    id: number;
    node_id: string;
    slug: string;
    /**
     * Description of the team
     */
    description: string | null;
    privacy: "open" | "closed" | "secret";
    /**
     * URL for the team
     */
    url: string;
    html_url: string;
    members_url: string;
    repositories_url: string;
    /**
     * Permission that the team will have for its repositories
     */
    permission: string;
  } | null;
}
export interface MembershipRemovedEvent {
  action: "removed";
  /**
   * The scope of the membership. Currently, can only be `team`.
   */
  scope: "team";
  member: User;
  sender: User;
  team: Team;
  organization: Organization;
  installation?: InstallationLite;
}
export interface MetaDeletedEvent {
  action: "deleted";
  /**
   * The id of the modified webhook.
   */
  hook_id: number;
  /**
   * The modified webhook. This will contain different keys based on the type of webhook it is: repository, organization, business, app, or GitHub Marketplace.
   */
  hook: {
    type: string;
    id: number;
    name: string;
    active: boolean;
    events: string[];
    config: {
      content_type: string;
      insecure_ssl: string;
      url: string;
    };
    updated_at: string;
    created_at: string;
  };
  repository: Repository;
  sender: User;
}
export interface MilestoneClosedEvent {
  action: "closed";
  milestone: Milestone & {
    state: "closed";
    closed_at: string;
  };
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface MilestoneCreatedEvent {
  action: "created";
  milestone: Milestone & {
    state: "open";
    closed_at: null;
  };
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface MilestoneDeletedEvent {
  action: "deleted";
  milestone: Milestone;
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface MilestoneEditedEvent {
  action: "edited";
  /**
   * The changes to the milestone if the action was `edited`.
   */
  changes: {
    description?: {
      /**
       * The previous version of the description if the action was `edited`.
       */
      from: string;
    };
    due_on?: {
      /**
       * The previous version of the due date if the action was `edited`.
       */
      from: string;
    };
    title?: {
      /**
       * The previous version of the title if the action was `edited`.
       */
      from: string;
    };
  };
  milestone: Milestone;
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface MilestoneOpenedEvent {
  action: "opened";
  milestone: Milestone & {
    state: "open";
    closed_at: null;
  };
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface OrgBlockBlockedEvent {
  action: "blocked";
  blocked_user: User;
  sender: User;
  installation?: InstallationLite;
  organization: Organization;
}
export interface OrgBlockUnblockedEvent {
  action: "unblocked";
  blocked_user: User;
  sender: User;
  installation?: InstallationLite;
  organization: Organization;
}
export interface OrganizationDeletedEvent {
  action: "deleted";
  membership: Membership;
  sender: User;
  installation?: InstallationLite;
  organization: Organization;
}
/**
 * The membership between the user and the organization. Not present when the action is `member_invited`.
 */
export interface Membership {
  url: string;
  state: string;
  role: string;
  organization_url: string;
  user: User;
}
export interface OrganizationMemberAddedEvent {
  action: "member_added";
  membership: Membership;
  sender: User;
  installation?: InstallationLite;
  organization: Organization;
}
export interface OrganizationMemberInvitedEvent {
  action: "member_invited";
  /**
   * The invitation for the user or email if the action is `member_invited`.
   */
  invitation: {};
  sender: User;
  installation?: InstallationLite;
  organization: Organization;
}
export interface OrganizationMemberRemovedEvent {
  action: "member_removed";
  membership: Membership;
  sender: User;
  installation?: InstallationLite;
  organization: Organization;
}
export interface OrganizationRenamedEvent {
  action: "renamed";
  membership: Membership;
  sender: User;
  installation?: InstallationLite;
  organization: Organization;
}
export interface PackagePublishedEvent {
  action: "published";
  /**
   * Information about the package.
   */
  package: {
    id: number;
    name: string;
    package_type: string;
    html_url: string;
    created_at: string;
    updated_at: string;
    owner: User;
    package_version: {
      id: number;
      version: string;
      summary: string;
      body: string;
      body_html: string;
      release: {
        url: string;
        html_url: string;
        id: number;
        tag_name: string;
        target_commitish: string;
        name: string;
        draft: boolean;
        author: User;
        prerelease: boolean;
        created_at: string;
        published_at: string;
      };
      manifest: string;
      html_url: string;
      tag_name: string;
      target_commitish: string;
      target_oid: string;
      draft: boolean;
      prerelease: boolean;
      created_at: string;
      updated_at: string;
      metadata: unknown[];
      package_files: {
        download_url: string;
        id: number;
        name: string;
        sha256: string;
        sha1: string;
        md5: string;
        content_type: string;
        state: string;
        size: number;
        created_at: string;
        updated_at: string;
      }[];
      author: User;
      installation_command: string;
    };
    registry: {
      about_url: string;
      name: string;
      type: string;
      url: string;
      vendor: string;
    };
  };
  repository: Repository;
  sender: User;
  organization?: Organization;
}
export interface PackageUpdatedEvent {
  action: "updated";
  /**
   * Information about the package.
   */
  package: {
    id: number;
    name: string;
    package_type: string;
    html_url: string;
    created_at: string;
    updated_at: string;
    owner: User;
    package_version: {
      id: number;
      version: string;
      summary: string;
      body: string;
      body_html: string;
      release: {
        url: string;
        html_url: string;
        id: number;
        tag_name: string;
        target_commitish: string;
        name: string;
        draft: boolean;
        author: User;
        prerelease: boolean;
        created_at: string;
        published_at: string;
      };
      manifest: string;
      html_url: string;
      tag_name: string;
      target_commitish: string;
      target_oid: string;
      draft: boolean;
      prerelease: boolean;
      created_at: string;
      updated_at: string;
      metadata: unknown[];
      package_files: {
        download_url: string;
        id: number;
        name: string;
        sha256: string;
        sha1: string;
        md5: string;
        content_type: string;
        state: string;
        size: number;
        created_at: string;
        updated_at: string;
      }[];
      author: User;
      installation_command: string;
    };
    registry: {
      about_url: string;
      name: string;
      type: string;
      url: string;
      vendor: string;
    };
  };
  repository: Repository;
  sender: User;
  organization?: Organization;
}
/**
 * Page Build
 */
export interface PageBuildEvent {
  id: number;
  /**
   * The [List GitHub Pages builds](https://docs.github.com/en/rest/reference/repos#list-github-pages-builds) itself.
   */
  build: {
    url: string;
    status: string;
    error: {
      message: string | null;
    };
    pusher: User;
    commit: string;
    duration: number;
    created_at: string;
    updated_at: string;
  };
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface PingEvent {
  zen: string;
  hook_id: number;
  /**
   * The [webhook configuration](https://docs.github.com/en/rest/reference/repos#get-a-repository-webhook).
   */
  hook: {
    type: string;
    id: number;
    name: string;
    active: boolean;
    events: string[];
    config: {
      content_type: string;
      secret?: string;
      url: string;
      insecure_ssl: string;
    };
    updated_at: string;
    created_at: string;
    url: string;
    test_url?: string;
    ping_url: string;
    last_response?: {
      code: null;
      status: string;
      message: null;
    };
  };
  repository?: Repository;
  sender?: User;
  organization?: Organization;
}
export interface ProjectClosedEvent {
  action: "closed";
  project: Project;
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface Project {
  owner_url: string;
  url: string;
  html_url: string;
  columns_url: string;
  id: number;
  node_id: string;
  /**
   * Name of the project
   */
  name: string;
  /**
   * Body of the project
   */
  body: string | null;
  number: number;
  /**
   * State of the project; either 'open' or 'closed'
   */
  state: "open" | "closed";
  creator: User;
  created_at: string;
  updated_at: string;
}
export interface ProjectCreatedEvent {
  action: "created";
  project: Project;
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface ProjectDeletedEvent {
  action: "deleted";
  project: Project;
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface ProjectEditedEvent {
  action: "edited";
  /**
   * The changes to the project if the action was `edited`.
   */
  changes: {
    name?: {
      /**
       * The changes to the project if the action was `edited`.
       */
      from: string;
    };
    body?: {
      /**
       * The previous version of the body if the action was `edited`.
       */
      from: string;
    };
  };
  project: Project;
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface ProjectReopenedEvent {
  action: "reopened";
  project: Project;
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface ProjectCardConvertedEvent {
  action: "converted";
  project_card: ProjectCard;
  repository: Repository;
  sender: User;
  organization?: Organization;
  installation?: InstallationLite;
}
export interface ProjectCard {
  url: string;
  project_url: string;
  column_url: string;
  column_id: number;
  /**
   * The project card's ID
   */
  id: number;
  node_id: string;
  note: string;
  /**
   * Whether or not the card is archived
   */
  archived: boolean;
  creator: User;
  created_at: string;
  updated_at: string;
  content_url: string;
}
export interface ProjectCardCreatedEvent {
  action: "created";
  project_card: ProjectCard;
  repository: Repository;
  sender: User;
  organization?: Organization;
  installation?: InstallationLite;
}
export interface ProjectCardDeletedEvent {
  action: "deleted";
  project_card: ProjectCard;
  repository: Repository;
  sender: User;
  organization?: Organization;
  installation?: InstallationLite;
}
export interface ProjectCardEditedEvent {
  action: "edited";
  project_card: ProjectCard;
  repository: Repository;
  sender: User;
  organization?: Organization;
  installation?: InstallationLite;
}
export interface ProjectCardMovedEvent {
  action: "moved";
  project_card: ProjectCard;
  repository: Repository;
  sender: User;
  organization?: Organization;
  installation?: InstallationLite;
}
export interface ProjectColumnCreatedEvent {
  action: "created";
  project_column: ProjectColumn;
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface ProjectColumn {
  url: string;
  project_url: string;
  cards_url: string;
  /**
   * The unique identifier of the project column
   */
  id: number;
  node_id: string;
  /**
   * Name of the project column
   */
  name: string;
  created_at: string;
  updated_at: string;
}
export interface ProjectColumnDeletedEvent {
  action: "deleted";
  project_column: ProjectColumn;
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface ProjectColumnEditedEvent {
  action: "edited";
  project_column: ProjectColumn;
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface ProjectColumnMovedEvent {
  action: "moved";
  project_column: ProjectColumn;
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
/**
 * When a private repository is made public.
 */
export interface PublicEvent {
  repository: Repository & {
    private: false;
  };
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface PullRequestAssignedEvent {
  action: "assigned";
  /**
   * The pull request number.
   */
  number: number;
  pull_request: PullRequest;
  assignee: User;
  repository: Repository;
  installation?: InstallationLite;
  organization?: Organization;
  sender: User;
}
export interface PullRequest {
  url: string;
  id: number;
  node_id: string;
  html_url: string;
  diff_url: string;
  patch_url: string;
  issue_url: string;
  /**
   * Number uniquely identifying the pull request within its repository.
   */
  number: number;
  /**
   * State of this Pull Request. Either `open` or `closed`.
   */
  state: "open" | "closed";
  locked: boolean;
  /**
   * The title of the pull request.
   */
  title: string;
  user: User;
  body: string;
  created_at: string;
  updated_at: string;
  closed_at: string | null;
  merged_at: string | null;
  merge_commit_sha: string | null;
  assignee: User | null;
  assignees: User[];
  requested_reviewers: (User | Team)[];
  requested_teams: Team[];
  labels: Label[];
  milestone: Milestone | null;
  commits_url: string;
  review_comments_url: string;
  review_comment_url: string;
  comments_url: string;
  statuses_url: string;
  head: {
    label: string;
    ref: string;
    sha: string;
    user: User;
    repo: Repository;
  };
  base: {
    label: string;
    ref: string;
    sha: string;
    user: User;
    repo: Repository;
  };
  _links: {
    self: Link;
    html: Link;
    issue: Link;
    comments: Link;
    review_comments: Link;
    review_comment: Link;
    commits: Link;
    statuses: Link;
  };
  author_association: AuthorAssociation;
  auto_merge: null;
  active_lock_reason: "resolved" | "off-topic" | "too heated" | "spam" | null;
  /**
   * Indicates whether or not the pull request is a draft.
   */
  draft: boolean;
  merged: boolean | null;
  mergeable: boolean | null;
  rebaseable: boolean | null;
  mergeable_state: string;
  merged_by: User | null;
  comments: number;
  review_comments: number;
  /**
   * Indicates whether maintainers can modify the pull request.
   */
  maintainer_can_modify: boolean;
  commits: number;
  additions: number;
  deletions: number;
  changed_files: number;
}
export interface Link {
  href: string;
}
export interface PullRequestAutoMergeDisabledEvent {
  action: "auto_merge_disabled";
  number: number;
  pull_request: PullRequest;
  repository: Repository;
  installation?: InstallationLite;
  organization?: Organization;
  sender: User;
}
export interface PullRequestAutoMergeEnabledEvent {
  action: "auto_merge_enabled";
  number: number;
  pull_request: PullRequest;
  repository: Repository;
  installation?: InstallationLite;
  organization?: Organization;
  sender: User;
}
export interface PullRequestClosedEvent {
  action: "closed";
  /**
   * The pull request number.
   */
  number: number;
  pull_request: PullRequest & {
    /**
     * State of this Pull Request. Either `open` or `closed`.
     */
    state: "closed";
    closed_at: string;
    merged: boolean;
  };
  repository: Repository;
  installation?: InstallationLite;
  organization?: Organization;
  sender: User;
}
export interface PullRequestConvertedToDraftEvent {
  action: "converted_to_draft";
  /**
   * The pull request number.
   */
  number: number;
  pull_request: PullRequest & {
    closed_at: null;
    merged_at: null;
    merge_commit_sha: null;
    /**
     * Indicates whether or not the pull request is a draft.
     */
    draft: true;
    merged: boolean;
    merged_by: null;
  };
  repository: Repository;
  installation?: InstallationLite;
  organization?: Organization;
  sender: User;
}
export interface PullRequestEditedEvent {
  action: "edited";
  /**
   * The pull request number.
   */
  number: number;
  /**
   * The changes to the comment if the action was `edited`.
   */
  changes: {
    body?: {
      /**
       * The previous version of the body if the action was `edited`.
       */
      from: string;
    };
    title?: {
      /**
       * The previous version of the title if the action was `edited`.
       */
      from: string;
    };
  };
  pull_request: PullRequest;
  repository: Repository;
  installation?: InstallationLite;
  organization?: Organization;
  sender: User;
}
export interface PullRequestLabeledEvent {
  action: "labeled";
  /**
   * The pull request number.
   */
  number: number;
  pull_request: PullRequest;
  label: Label;
  repository: Repository;
  installation?: InstallationLite;
  organization?: Organization;
  sender: User;
}
export interface PullRequestLockedEvent {
  action: "locked";
  /**
   * The pull request number.
   */
  number: number;
  pull_request: PullRequest;
  repository: Repository;
  installation?: InstallationLite;
  organization?: Organization;
  sender: User;
}
export interface PullRequestOpenedEvent {
  action: "opened";
  /**
   * The pull request number.
   */
  number: number;
  pull_request: PullRequest & {
    state: "open";
    closed_at: null;
    merged_at: null;
    merge_commit_sha: null;
    active_lock_reason: null;
    merged_by: null;
  };
  repository: Repository;
  installation?: InstallationLite;
  organization?: Organization;
  sender: User;
}
export interface PullRequestReadyForReviewEvent {
  action: "ready_for_review";
  /**
   * The pull request number.
   */
  number: number;
  pull_request: PullRequest & {
    state: "open";
    closed_at: null;
    merged_at: null;
    merge_commit_sha: null;
    /**
     * Indicates whether or not the pull request is a draft.
     */
    draft: false;
    merged: boolean;
    merged_by: null;
  };
  repository: Repository;
  installation?: InstallationLite;
  organization?: Organization;
  sender: User;
}
export interface PullRequestReopenedEvent {
  action: "reopened";
  /**
   * The pull request number.
   */
  number: number;
  pull_request: PullRequest & {
    state: "open";
    closed_at: null;
    merged_at: null;
    merge_commit_sha: null;
    merged: boolean;
    merged_by: null;
  };
  repository: Repository;
  installation?: InstallationLite;
  organization?: Organization;
  sender: User;
}
export interface PullRequestReviewRequestRemovedEvent {
  action: "review_request_removed";
  /**
   * The pull request number.
   */
  number: number;
  pull_request: PullRequest;
  requested_reviewer: User;
  repository: Repository;
  installation?: InstallationLite;
  organization?: Organization;
  sender: User;
}
export interface PullRequestReviewRequestedEvent {
  action: "review_requested";
  /**
   * The pull request number.
   */
  number: number;
  pull_request: PullRequest;
  requested_reviewer: User;
  repository: Repository;
  installation?: InstallationLite;
  organization?: Organization;
  sender: User;
}
export interface PullRequestSynchronizeEvent {
  action: "synchronize";
  /**
   * The pull request number.
   */
  number: number;
  pull_request: PullRequest;
  repository: Repository;
  installation?: InstallationLite;
  organization?: Organization;
  sender: User;
}
export interface PullRequestUnassignedEvent {
  action: "unassigned";
  /**
   * The pull request number.
   */
  number: number;
  pull_request: PullRequest;
  assignee: User;
  repository: Repository;
  installation?: InstallationLite;
  organization?: Organization;
  sender: User;
}
export interface PullRequestUnlabeledEvent {
  action: "unlabeled";
  /**
   * The pull request number.
   */
  number: number;
  pull_request: PullRequest;
  label: Label;
  repository: Repository;
  installation?: InstallationLite;
  organization?: Organization;
  sender: User;
}
export interface PullRequestUnlockedEvent {
  action: "unlocked";
  /**
   * The pull request number.
   */
  number: number;
  pull_request: PullRequest;
  repository: Repository;
  installation?: InstallationLite;
  organization?: Organization;
  sender: User;
}
export interface PullRequestReviewDismissedEvent {
  action: "dismissed";
  /**
   * The review that was affected.
   */
  review: {
    /**
     * Unique identifier of the review
     */
    id: number;
    node_id: string;
    user: User;
    /**
     * The text of the review.
     */
    body: string | null;
    /**
     * A commit SHA for the review.
     */
    commit_id: string;
    submitted_at: string;
    state: "dismissed";
    html_url: string;
    pull_request_url: string;
    author_association: AuthorAssociation;
    _links: {
      html: Link;
      pull_request: Link;
    };
  };
  pull_request: SimplePullRequest;
  repository: Repository;
  installation?: InstallationLite;
  organization?: Organization;
  sender: User;
}
export interface SimplePullRequest {
  url: string;
  id: number;
  node_id: string;
  html_url: string;
  diff_url: string;
  patch_url: string;
  issue_url: string;
  number: number;
  state: "open" | "closed";
  locked: boolean;
  title: string;
  user: User;
  body: string;
  created_at: string;
  updated_at: string;
  closed_at: string | null;
  merged_at: string | null;
  merge_commit_sha: string | null;
  assignee: User | null;
  assignees: User[];
  requested_reviewers: (User | Team)[];
  requested_teams: Team[];
  labels: Label[];
  milestone: Milestone | null;
  draft: boolean;
  commits_url: string;
  review_comments_url: string;
  review_comment_url: string;
  comments_url: string;
  statuses_url: string;
  head: {
    label: string;
    ref: string;
    sha: string;
    user: User;
    repo: Repository;
  };
  base: {
    label: string;
    ref: string;
    sha: string;
    user: User;
    repo: Repository;
  };
  _links: {
    self: Link;
    html: Link;
    issue: Link;
    comments: Link;
    review_comments: Link;
    review_comment: Link;
    commits: Link;
    statuses: Link;
  };
  author_association: AuthorAssociation;
  active_lock_reason: "resolved" | "off-topic" | "too heated" | "spam" | null;
}
export interface PullRequestReviewEditedEvent {
  action: "edited";
  changes: {
    body: {
      /**
       * The previous version of the body if the action was `edited`.
       */
      from: string;
    };
  };
  /**
   * The review that was affected.
   */
  review: {
    /**
     * Unique identifier of the review
     */
    id: number;
    node_id: string;
    user: User;
    /**
     * The text of the review.
     */
    body: string | null;
    /**
     * A commit SHA for the review.
     */
    commit_id: string;
    submitted_at: string;
    state: string;
    html_url: string;
    pull_request_url: string;
    author_association: AuthorAssociation;
    _links: {
      html: Link;
      pull_request: Link;
    };
  };
  pull_request: SimplePullRequest;
  repository: Repository;
  installation?: InstallationLite;
  organization?: Organization;
  sender: User;
}
export interface PullRequestReviewSubmittedEvent {
  action: "submitted";
  /**
   * The review that was affected.
   */
  review: {
    /**
     * Unique identifier of the review
     */
    id: number;
    node_id: string;
    user: User;
    /**
     * The text of the review.
     */
    body: string | null;
    /**
     * A commit SHA for the review.
     */
    commit_id: string;
    submitted_at: string;
    state: string;
    html_url: string;
    pull_request_url: string;
    author_association: AuthorAssociation;
    _links: {
      html: Link;
      pull_request: Link;
    };
  };
  pull_request: SimplePullRequest;
  repository: Repository;
  installation?: InstallationLite;
  organization?: Organization;
  sender: User;
}
export interface PullRequestReviewCommentCreatedEvent {
  action: "created";
  /**
   * The [comment](https://docs.github.com/en/rest/reference/pulls#comments) itself.
   */
  comment: {
    /**
     * URL for the pull request review comment
     */
    url: string;
    /**
     * The ID of the pull request review to which the comment belongs.
     */
    pull_request_review_id: number;
    /**
     * The ID of the pull request review comment.
     */
    id: number;
    /**
     * The node ID of the pull request review comment.
     */
    node_id: string;
    /**
     * The diff of the line that the comment refers to.
     */
    diff_hunk: string;
    /**
     * The relative path of the file to which the comment applies.
     */
    path: string;
    /**
     * The line index in the diff to which the comment applies.
     */
    position: number;
    /**
     * The index of the original line in the diff to which the comment applies.
     */
    original_position: number;
    /**
     * The SHA of the commit to which the comment applies.
     */
    commit_id: string;
    /**
     * The SHA of the original commit to which the comment applies.
     */
    original_commit_id: string;
    user: User;
    /**
     * The text of the comment.
     */
    body: string;
    created_at: string;
    updated_at: string;
    /**
     * HTML URL for the pull request review comment.
     */
    html_url: string;
    /**
     * URL for the pull request that the review comment belongs to.
     */
    pull_request_url: string;
    author_association: AuthorAssociation;
    _links: {
      self: Link;
      html: Link;
      pull_request: Link;
    };
    /**
     * The first line of the range for a multi-line comment.
     */
    start_line?: number | null;
    /**
     * The first line of the range for a multi-line comment.
     */
    original_start_line?: number | null;
    /**
     * The side of the first line of the range for a multi-line comment.
     */
    start_side?: "LEFT" | "RIGHT" | null;
    /**
     * The line of the blob to which the comment applies. The last line of the range for a multi-line comment
     */
    line?: number;
    /**
     * The line of the blob to which the comment applies. The last line of the range for a multi-line comment
     */
    original_line?: number;
    /**
     * The side of the first line of the range for a multi-line comment.
     */
    side?: "LEFT" | "RIGHT";
    /**
     * The comment ID to reply to.
     */
    in_reply_to_id?: number;
  };
  pull_request: {
    url: string;
    id: number;
    node_id: string;
    html_url: string;
    diff_url: string;
    patch_url: string;
    issue_url: string;
    number: number;
    state: "open" | "closed";
    locked: boolean;
    title: string;
    user: User;
    body: string;
    created_at: string;
    updated_at: string;
    closed_at: string | null;
    merged_at: string | null;
    merge_commit_sha: string | null;
    assignee: User | null;
    assignees: User[];
    requested_reviewers: (User | Team)[];
    requested_teams: Team[];
    labels: Label[];
    milestone: Milestone | null;
    commits_url: string;
    review_comments_url: string;
    review_comment_url: string;
    comments_url: string;
    statuses_url: string;
    head: {
      label: string;
      ref: string;
      sha: string;
      user: User;
      repo: Repository;
    };
    base: {
      label: string;
      ref: string;
      sha: string;
      user: User;
      repo: Repository;
    };
    _links: {
      self: Link;
      html: Link;
      issue: Link;
      comments: Link;
      review_comments: Link;
      review_comment: Link;
      commits: Link;
      statuses: Link;
    };
    author_association: AuthorAssociation;
  };
  repository: Repository;
  installation?: InstallationLite;
  organization?: Organization;
  sender: User;
}
export interface PullRequestReviewCommentDeletedEvent {
  action: "deleted";
  /**
   * The [comment](https://docs.github.com/en/rest/reference/pulls#comments) itself.
   */
  comment: {
    /**
     * URL for the pull request review comment
     */
    url: string;
    /**
     * The ID of the pull request review to which the comment belongs.
     */
    pull_request_review_id: number;
    /**
     * The ID of the pull request review comment.
     */
    id: number;
    /**
     * The node ID of the pull request review comment.
     */
    node_id: string;
    /**
     * The diff of the line that the comment refers to.
     */
    diff_hunk: string;
    /**
     * The relative path of the file to which the comment applies.
     */
    path: string;
    /**
     * The line index in the diff to which the comment applies.
     */
    position: number;
    /**
     * The index of the original line in the diff to which the comment applies.
     */
    original_position: number;
    /**
     * The SHA of the commit to which the comment applies.
     */
    commit_id: string;
    /**
     * The SHA of the original commit to which the comment applies.
     */
    original_commit_id: string;
    user: User;
    /**
     * The text of the comment.
     */
    body: string;
    created_at: string;
    updated_at: string;
    /**
     * HTML URL for the pull request review comment.
     */
    html_url: string;
    /**
     * URL for the pull request that the review comment belongs to.
     */
    pull_request_url: string;
    author_association: AuthorAssociation;
    _links: {
      self: Link;
      html: Link;
      pull_request: Link;
    };
    /**
     * The first line of the range for a multi-line comment.
     */
    start_line?: number | null;
    /**
     * The first line of the range for a multi-line comment.
     */
    original_start_line?: number | null;
    /**
     * The side of the first line of the range for a multi-line comment.
     */
    start_side?: "LEFT" | "RIGHT" | null;
    /**
     * The line of the blob to which the comment applies. The last line of the range for a multi-line comment
     */
    line?: number;
    /**
     * The line of the blob to which the comment applies. The last line of the range for a multi-line comment
     */
    original_line?: number;
    /**
     * The side of the first line of the range for a multi-line comment.
     */
    side?: "LEFT" | "RIGHT";
    /**
     * The comment ID to reply to.
     */
    in_reply_to_id?: number;
  };
  pull_request: {
    url: string;
    id: number;
    node_id: string;
    html_url: string;
    diff_url: string;
    patch_url: string;
    issue_url: string;
    number: number;
    state: "open" | "closed";
    locked: boolean;
    title: string;
    user: User;
    body: string;
    created_at: string;
    updated_at: string;
    closed_at: string | null;
    merged_at: string | null;
    merge_commit_sha: string | null;
    assignee: User | null;
    assignees: User[];
    requested_reviewers: (User | Team)[];
    requested_teams: Team[];
    labels: Label[];
    milestone: Milestone | null;
    commits_url: string;
    review_comments_url: string;
    review_comment_url: string;
    comments_url: string;
    statuses_url: string;
    head: {
      label: string;
      ref: string;
      sha: string;
      user: User;
      repo: Repository;
    };
    base: {
      label: string;
      ref: string;
      sha: string;
      user: User;
      repo: Repository;
    };
    _links: {
      self: Link;
      html: Link;
      issue: Link;
      comments: Link;
      review_comments: Link;
      review_comment: Link;
      commits: Link;
      statuses: Link;
    };
    author_association: AuthorAssociation;
  };
  repository: Repository;
  installation?: InstallationLite;
  organization?: Organization;
  sender: User;
}
export interface PullRequestReviewCommentEditedEvent {
  action: "edited";
  /**
   * The changes to the comment.
   */
  changes: {
    body?: {
      /**
       * The previous version of the body.
       */
      from: string;
    };
  };
  /**
   * The [comment](https://docs.github.com/en/rest/reference/pulls#comments) itself.
   */
  comment: {
    /**
     * URL for the pull request review comment
     */
    url: string;
    /**
     * The ID of the pull request review to which the comment belongs.
     */
    pull_request_review_id: number;
    /**
     * The ID of the pull request review comment.
     */
    id: number;
    /**
     * The node ID of the pull request review comment.
     */
    node_id: string;
    /**
     * The diff of the line that the comment refers to.
     */
    diff_hunk: string;
    /**
     * The relative path of the file to which the comment applies.
     */
    path: string;
    /**
     * The line index in the diff to which the comment applies.
     */
    position: number;
    /**
     * The index of the original line in the diff to which the comment applies.
     */
    original_position: number;
    /**
     * The SHA of the commit to which the comment applies.
     */
    commit_id: string;
    /**
     * The SHA of the original commit to which the comment applies.
     */
    original_commit_id: string;
    user: User;
    /**
     * The text of the comment.
     */
    body: string;
    created_at: string;
    updated_at: string;
    /**
     * HTML URL for the pull request review comment.
     */
    html_url: string;
    /**
     * URL for the pull request that the review comment belongs to.
     */
    pull_request_url: string;
    author_association: AuthorAssociation;
    _links: {
      self: Link;
      html: Link;
      pull_request: Link;
    };
    /**
     * The first line of the range for a multi-line comment.
     */
    start_line?: number | null;
    /**
     * The first line of the range for a multi-line comment.
     */
    original_start_line?: number | null;
    /**
     * The side of the first line of the range for a multi-line comment.
     */
    start_side?: "LEFT" | "RIGHT" | null;
    /**
     * The line of the blob to which the comment applies. The last line of the range for a multi-line comment
     */
    line?: number;
    /**
     * The line of the blob to which the comment applies. The last line of the range for a multi-line comment
     */
    original_line?: number;
    /**
     * The side of the first line of the range for a multi-line comment.
     */
    side?: "LEFT" | "RIGHT";
    /**
     * The comment ID to reply to.
     */
    in_reply_to_id?: number;
  };
  pull_request: {
    url: string;
    id: number;
    node_id: string;
    html_url: string;
    diff_url: string;
    patch_url: string;
    issue_url: string;
    number: number;
    state: "open" | "closed";
    locked: boolean;
    title: string;
    user: User;
    body: string;
    created_at: string;
    updated_at: string;
    closed_at: string | null;
    merged_at: string | null;
    merge_commit_sha: string | null;
    assignee: User | null;
    assignees: User[];
    requested_reviewers: (User | Team)[];
    requested_teams: Team[];
    labels: Label[];
    milestone: Milestone | null;
    commits_url: string;
    review_comments_url: string;
    review_comment_url: string;
    comments_url: string;
    statuses_url: string;
    head: {
      label: string;
      ref: string;
      sha: string;
      user: User;
      repo: Repository;
    };
    base: {
      label: string;
      ref: string;
      sha: string;
      user: User;
      repo: Repository;
    };
    _links: {
      self: Link;
      html: Link;
      issue: Link;
      comments: Link;
      review_comments: Link;
      review_comment: Link;
      commits: Link;
      statuses: Link;
    };
    author_association: AuthorAssociation;
  };
  repository: Repository;
  installation?: InstallationLite;
  organization?: Organization;
  sender: User;
}
export interface PushEvent {
  /**
   * The full git ref that was pushed. Example: `refs/heads/main`.
   */
  ref: string;
  /**
   * The SHA of the most recent commit on `ref` before the push.
   */
  before: string;
  /**
   * The SHA of the most recent commit on `ref` after the push.
   */
  after: string;
  created: boolean;
  deleted: boolean;
  forced: boolean;
  base_ref: null;
  compare: string;
  /**
   * An array of commit objects describing the pushed commits.
   */
  commits: Commit[];
  head_commit: Commit | null;
  repository: Repository;
  pusher: Committer;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface Commit {
  id: string;
  tree_id: string;
  /**
   * Whether this commit is distinct from any that have been pushed before.
   */
  distinct: boolean;
  /**
   * The commit message.
   */
  message: string;
  /**
   * The ISO 8601 timestamp of the commit.
   */
  timestamp: string;
  /**
   * URL that points to the commit API resource.
   */
  url: string;
  author: Committer & {
    username: string;
  };
  committer: Committer & {
    username: string;
  };
  /**
   * An array of files added in the commit.
   */
  added: string[];
  /**
   * An array of files modified by the commit.
   */
  removed: string[];
  /**
   * An array of files removed in the commit.
   */
  modified: string[];
}
export interface ReleaseCreatedEvent {
  action: "created";
  /**
   * The [release](https://docs.github.com/en/rest/reference/repos/#get-a-release) object.
   */
  release: {
    url: string;
    assets_url: string;
    upload_url: string;
    html_url: string;
    id: number;
    node_id: string;
    /**
     * The name of the tag.
     */
    tag_name: string;
    /**
     * Specifies the commitish value that determines where the Git tag is created from.
     */
    target_commitish: string;
    name: null;
    /**
     * true to create a draft (unpublished) release, false to create a published one.
     */
    draft: boolean;
    author: User;
    /**
     * Whether the release is identified as a prerelease or a full release.
     */
    prerelease: boolean;
    created_at: string | null;
    published_at: string | null;
    assets: ReleaseAsset[];
    tarball_url: string | null;
    zipball_url: string | null;
    body: string | null;
  };
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
/**
 * Data related to a release.
 */
export interface ReleaseAsset {
  url: string;
  browser_download_url: string;
  id: number;
  node_id: string;
  /**
   * The file name of the asset.
   */
  name: string;
  label: string;
  /**
   * State of the release asset.
   */
  state: "uploaded";
  content_type: string;
  size: number;
  download_count: number;
  created_at: string;
  updated_at: string;
  uploader?: User;
}
export interface ReleaseDeletedEvent {
  action: "deleted";
  /**
   * The [release](https://docs.github.com/en/rest/reference/repos/#get-a-release) object.
   */
  release: {
    url: string;
    assets_url: string;
    upload_url: string;
    html_url: string;
    id: number;
    node_id: string;
    /**
     * The name of the tag.
     */
    tag_name: string;
    /**
     * Specifies the commitish value that determines where the Git tag is created from.
     */
    target_commitish: string;
    name: null;
    /**
     * true to create a draft (unpublished) release, false to create a published one.
     */
    draft: boolean;
    author: User;
    /**
     * Whether the release is identified as a prerelease or a full release.
     */
    prerelease: boolean;
    created_at: string | null;
    published_at: string | null;
    assets: ReleaseAsset[];
    tarball_url: string | null;
    zipball_url: string | null;
    body: string | null;
  };
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface ReleaseEditedEvent {
  action: "edited";
  changes: {
    body?: {
      /**
       * The previous version of the body if the action was `edited`.
       */
      from: string;
    };
    name?: {
      /**
       * The previous version of the name if the action was `edited`.
       */
      from: string;
    };
  };
  /**
   * The [release](https://docs.github.com/en/rest/reference/repos/#get-a-release) object.
   */
  release: {
    url: string;
    assets_url: string;
    upload_url: string;
    html_url: string;
    id: number;
    node_id: string;
    /**
     * The name of the tag.
     */
    tag_name: string;
    /**
     * Specifies the commitish value that determines where the Git tag is created from.
     */
    target_commitish: string;
    name: null;
    /**
     * true to create a draft (unpublished) release, false to create a published one.
     */
    draft: boolean;
    author: User;
    /**
     * Whether the release is identified as a prerelease or a full release.
     */
    prerelease: boolean;
    created_at: string | null;
    published_at: string | null;
    assets: ReleaseAsset[];
    tarball_url: string | null;
    zipball_url: string | null;
    body: string | null;
  };
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface ReleasePrereleasedEvent {
  action: "prereleased";
  /**
   * The [release](https://docs.github.com/en/rest/reference/repos/#get-a-release) object.
   */
  release: {
    url: string;
    assets_url: string;
    upload_url: string;
    html_url: string;
    id: number;
    node_id: string;
    /**
     * The name of the tag.
     */
    tag_name: string;
    /**
     * Specifies the commitish value that determines where the Git tag is created from.
     */
    target_commitish: string;
    name: null;
    /**
     * true to create a draft (unpublished) release, false to create a published one.
     */
    draft: boolean;
    author: User;
    /**
     * Whether the release is identified as a prerelease or a full release.
     */
    prerelease: true;
    created_at: string | null;
    published_at: string | null;
    assets: ReleaseAsset[];
    tarball_url: string | null;
    zipball_url: string | null;
    body: string | null;
  };
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface ReleasePublishedEvent {
  action: "published";
  /**
   * The [release](https://docs.github.com/en/rest/reference/repos/#get-a-release) object.
   */
  release: {
    url: string;
    assets_url: string;
    upload_url: string;
    html_url: string;
    id: number;
    node_id: string;
    /**
     * The name of the tag.
     */
    tag_name: string;
    /**
     * Specifies the commitish value that determines where the Git tag is created from.
     */
    target_commitish: string;
    name: null;
    /**
     * true to create a draft (unpublished) release, false to create a published one.
     */
    draft: boolean;
    author: User;
    /**
     * Whether the release is identified as a prerelease or a full release.
     */
    prerelease: boolean;
    created_at: string | null;
    published_at: string | null;
    assets: ReleaseAsset[];
    tarball_url: string | null;
    zipball_url: string | null;
    body: string | null;
  };
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface ReleaseReleasedEvent {
  action: "released";
  /**
   * The [release](https://docs.github.com/en/rest/reference/repos/#get-a-release) object.
   */
  release: {
    url: string;
    assets_url: string;
    upload_url: string;
    html_url: string;
    id: number;
    node_id: string;
    /**
     * The name of the tag.
     */
    tag_name: string;
    /**
     * Specifies the commitish value that determines where the Git tag is created from.
     */
    target_commitish: string;
    name: null;
    /**
     * true to create a draft (unpublished) release, false to create a published one.
     */
    draft: boolean;
    author: User;
    /**
     * Whether the release is identified as a prerelease or a full release.
     */
    prerelease: boolean;
    created_at: string | null;
    published_at: string | null;
    assets: ReleaseAsset[];
    tarball_url: string | null;
    zipball_url: string | null;
    body: string | null;
  };
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface ReleaseUnpublishedEvent {
  action: "unpublished";
  /**
   * The [release](https://docs.github.com/en/rest/reference/repos/#get-a-release) object.
   */
  release: {
    url: string;
    assets_url: string;
    upload_url: string;
    html_url: string;
    id: number;
    node_id: string;
    /**
     * The name of the tag.
     */
    tag_name: string;
    /**
     * Specifies the commitish value that determines where the Git tag is created from.
     */
    target_commitish: string;
    name: null;
    /**
     * true to create a draft (unpublished) release, false to create a published one.
     */
    draft: boolean;
    author: User;
    /**
     * Whether the release is identified as a prerelease or a full release.
     */
    prerelease: boolean;
    created_at: string | null;
    published_at: string | null;
    assets: ReleaseAsset[];
    tarball_url: string | null;
    zipball_url: string | null;
    body: string | null;
  };
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface RepositoryArchivedEvent {
  action: "archived";
  repository: Repository & {
    /**
     * Whether the repository is archived.
     */
    archived: true;
  };
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface RepositoryCreatedEvent {
  action: "created";
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface RepositoryDeletedEvent {
  action: "deleted";
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface RepositoryEditedEvent {
  action: "edited";
  changes: {
    description?: {
      from: string;
    };
    default_branch?: {
      from: string;
    };
    homepage?: {
      from: string;
    };
  };
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface RepositoryPrivatizedEvent {
  action: "privatized";
  repository: Repository & {
    /**
     * Whether the repository is private or public.
     */
    private: true;
  };
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface RepositoryPublicizedEvent {
  action: "publicized";
  repository: Repository & {
    /**
     * Whether the repository is private or public.
     */
    private: false;
  };
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface RepositoryRenamedEvent {
  action: "renamed";
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface RepositoryTransferredEvent {
  action: "transferred";
  changes: {
    owner: {
      from: {
        user?: User;
      };
    };
  };
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface RepositoryUnarchivedEvent {
  action: "unarchived";
  repository: Repository & {
    /**
     * Whether the repository is archived.
     */
    archived: false;
  };
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface RepositoryDispatchOnDemandTestEvent {
  action: "on-demand-test";
  branch: string;
  client_payload: {
    [k: string]: unknown;
  };
  repository: Repository;
  sender: User;
  installation: InstallationLite;
  organization?: Organization;
}
export interface RepositoryImportEvent {
  status: "success" | "cancelled" | "failure";
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface RepositoryVulnerabilityAlertCreateEvent {
  action: "create";
  /**
   * The security alert of the vulnerable dependency.
   */
  alert: {
    id: number;
    affected_range: string;
    affected_package_name: string;
    dismisser?: User;
    dismiss_reason?: string;
    dismissed_at?: string;
    ghsa_id?: string;
    external_reference: string;
    external_identifier: string;
    fixed_in: string;
    created_at?: string;
  };
  repository: Repository;
  sender: User;
  organization?: Organization;
}
export interface RepositoryVulnerabilityAlertDismissEvent {
  action: "dismiss";
  /**
   * The security alert of the vulnerable dependency.
   */
  alert: {
    id: number;
    affected_range: string;
    affected_package_name: string;
    dismisser: User;
    dismiss_reason: string;
    dismissed_at: string;
    ghsa_id?: string;
    external_reference: string;
    external_identifier: string;
    fixed_in: string;
    created_at?: string;
  };
  repository: Repository;
  sender: User;
  organization?: Organization;
}
export interface RepositoryVulnerabilityAlertResolveEvent {
  action: "resolve";
  /**
   * The security alert of the vulnerable dependency.
   */
  alert: {
    id: number;
    affected_range: string;
    affected_package_name: string;
    dismisser?: User;
    dismiss_reason?: string;
    dismissed_at?: string;
    ghsa_id?: string;
    external_reference: string;
    external_identifier: string;
    fixed_in: string;
    created_at?: string;
  };
  repository: Repository;
  sender: User;
  organization?: Organization;
}
export interface SecretScanningAlertCreatedEvent {
  action: "created";
  /**
   * The secret scanning alert involved in the event.
   */
  alert: {
    number: number;
    secret_type: string;
    resolution: null;
    resolved_by: null;
    resolved_at: null;
  };
  repository: Repository;
  organization?: Organization;
  installation?: InstallationLite;
}
export interface SecretScanningAlertReopenedEvent {
  action: "reopened";
  /**
   * The secret scanning alert involved in the event.
   */
  alert: {
    number: number;
    secret_type: string;
    resolution: null;
    resolved_by: null;
    resolved_at: null;
  };
  repository: Repository;
  organization?: Organization;
  installation?: InstallationLite;
  sender: User;
}
export interface SecretScanningAlertResolvedEvent {
  action: "resolved";
  /**
   * The secret scanning alert involved in the event.
   */
  alert: {
    number: number;
    secret_type: string;
    resolution: "false_positive" | "wontfix" | "revoked" | "used_in_tests";
    resolved_by: User;
    resolved_at: string;
  };
  repository: Repository;
  organization?: Organization;
  installation?: InstallationLite;
  sender: User;
}
export interface SecurityAdvisoryPerformedEvent {
  action: "performed";
  /**
   * The details of the security advisory, including summary, description, and severity.
   */
  security_advisory: {
    ghsa_id: string;
    summary: string;
    description: string;
    severity: string;
    identifiers: {
      value: string;
      type: string;
    }[];
    references: {
      url: string;
    }[];
    published_at: string;
    updated_at: string;
    withdrawn_at: string | null;
    vulnerabilities: {
      package: {
        ecosystem: string;
        name: string;
      };
      severity: string;
      vulnerable_version_range: string;
      first_patched_version: {
        identifier: string;
      } | null;
    }[];
  };
}
export interface SecurityAdvisoryPublishedEvent {
  action: "published";
  /**
   * The details of the security advisory, including summary, description, and severity.
   */
  security_advisory: {
    ghsa_id: string;
    summary: string;
    description: string;
    severity: string;
    identifiers: {
      value: string;
      type: string;
    }[];
    references: {
      url: string;
    }[];
    published_at: string;
    updated_at: string;
    withdrawn_at: string | null;
    vulnerabilities: {
      package: {
        ecosystem: string;
        name: string;
      };
      severity: string;
      vulnerable_version_range: string;
      first_patched_version: {
        identifier: string;
      } | null;
    }[];
  };
}
export interface SecurityAdvisoryUpdatedEvent {
  action: "updated";
  /**
   * The details of the security advisory, including summary, description, and severity.
   */
  security_advisory: {
    ghsa_id: string;
    summary: string;
    description: string;
    severity: string;
    identifiers: {
      value: string;
      type: string;
    }[];
    references: {
      url: string;
    }[];
    published_at: string;
    updated_at: string;
    withdrawn_at: string | null;
    vulnerabilities: {
      package: {
        ecosystem: string;
        name: string;
      };
      severity: string;
      vulnerable_version_range: string;
      first_patched_version: {
        identifier: string;
      } | null;
    }[];
  };
}
export interface SponsorshipCancelledEvent {
  action: "cancelled";
  sponsorship: {
    node_id: string;
    created_at: string;
    sponsorable: User;
    sponsor: User;
    privacy_level: string;
    tier: SponsorshipTier;
  };
  sender: User;
}
/**
 * The `tier_changed` and `pending_tier_change` will include the original tier before the change or pending change. For more information, see the pending tier change payload.
 */
export interface SponsorshipTier {
  node_id: string;
  created_at: string;
  description: string;
  monthly_price_in_cents: number;
  monthly_price_in_dollars: number;
  name: string;
  is_one_time: boolean;
  is_custom_ammount: boolean;
}
export interface SponsorshipCreatedEvent {
  action: "created";
  sponsorship: {
    node_id: string;
    created_at: string;
    sponsorable: User;
    sponsor: User;
    privacy_level: string;
    tier: SponsorshipTier;
  };
  sender: User;
}
export interface SponsorshipEditedEvent {
  action: "edited";
  sponsorship: {
    node_id: string;
    created_at: string;
    sponsorable: User;
    sponsor: User;
    privacy_level: string;
    tier: SponsorshipTier;
  };
  changes: {
    privacy_level?: {
      /**
       * The `edited` event types include the details about the change when someone edits a sponsorship to change the privacy.
       */
      from: string;
    };
  };
  sender: User;
}
export interface SponsorshipPendingCancellationEvent {
  action: "pending_cancellation";
  sponsorship: {
    node_id: string;
    created_at: string;
    sponsorable: User;
    sponsor: User;
    privacy_level: string;
    tier: SponsorshipTier;
  };
  /**
   * The `pending_cancellation` and `pending_tier_change` event types will include the date the cancellation or tier change will take effect.
   */
  effective_date?: string;
  sender: User;
}
export interface SponsorshipPendingTierChangeEvent {
  action: "pending_tier_change";
  sponsorship: {
    node_id: string;
    created_at: string;
    sponsorable: User;
    sponsor: User;
    privacy_level: string;
    tier: SponsorshipTier;
  };
  /**
   * The `pending_cancellation` and `pending_tier_change` event types will include the date the cancellation or tier change will take effect.
   */
  effective_date?: string;
  changes: {
    tier: {
      from: SponsorshipTier;
    };
  };
  sender: User;
}
export interface SponsorshipTierChangedEvent {
  action: "tier_changed";
  sponsorship: {
    node_id: string;
    created_at: string;
    sponsorable: User;
    sponsor: User;
    privacy_level: string;
    tier: SponsorshipTier;
  };
  changes: {
    tier: {
      from: SponsorshipTier;
    };
  };
  sender: User;
}
export interface StarCreatedEvent {
  action: "created";
  /**
   * The time the star was created. This is a timestamp in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`. Will be `null` for the `deleted` action.
   */
  starred_at: string;
  repository: Repository;
  sender: User;
  organization?: Organization;
  installation?: InstallationLite;
}
export interface StarDeletedEvent {
  action: "deleted";
  /**
   * The time the star was created. This is a timestamp in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`. Will be `null` for the `deleted` action.
   */
  starred_at: null;
  repository: Repository;
  sender: User;
  organization?: Organization;
  installation?: InstallationLite;
}
export interface StatusEvent {
  /**
   * The unique identifier of the status.
   */
  id: number;
  /**
   * The Commit SHA.
   */
  sha: string;
  name: string;
  avatar_url?: string | null;
  /**
   * The optional link added to the status.
   */
  target_url: string | null;
  context: string;
  /**
   * The optional human-readable description added to the status.
   */
  description: string | null;
  /**
   * The new state. Can be `pending`, `success`, `failure`, or `error`.
   */
  state: "pending" | "success" | "failure" | "error";
  commit: {
    sha: string;
    node_id: string;
    commit: {
      author: Committer & {
        date: string;
      };
      committer: Committer & {
        date: string;
      };
      message: string;
      tree: {
        sha: string;
        url: string;
      };
      url: string;
      comment_count: number;
      verification: {
        verified: boolean;
        reason:
          | "expired_key"
          | "not_signing_key"
          | "gpgverify_error"
          | "gpgverify_unavailable"
          | "unsigned"
          | "unknown_signature_type"
          | "no_user"
          | "unverified_email"
          | "bad_email"
          | "unknown_key"
          | "malformed_signature"
          | "invalid"
          | "valid";
        signature: string | null;
        payload: string | null;
      };
    };
    url: string;
    html_url: string;
    comments_url: string;
    author: User | null;
    committer: User | null;
    parents: {
      sha: string;
      url: string;
      html_url: string;
    }[];
  };
  /**
   * An array of branch objects containing the status' SHA. Each branch contains the given SHA, but the SHA may or may not be the head of the branch. The array includes a maximum of 10 branches.
   */
  branches: {
    name: string;
    commit: {
      sha: string;
      url: string;
    };
    protected: boolean;
  }[];
  created_at: string;
  updated_at: string;
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface TeamAddedToRepositoryEvent {
  action: "added_to_repository";
  team: Team;
  repository?: Repository;
  sender: User;
  organization: Organization;
}
export interface TeamCreatedEvent {
  action: "created";
  team: Team;
  repository?: Repository;
  sender: User;
  organization: Organization;
}
export interface TeamDeletedEvent {
  action: "deleted";
  team: Team;
  repository?: Repository;
  sender: User;
  organization: Organization;
}
export interface TeamEditedEvent {
  action: "edited";
  /**
   * The changes to the team if the action was `edited`.
   */
  changes: {
    description?: {
      /**
       * The previous version of the description if the action was `edited`.
       */
      from: string;
    };
    name?: {
      /**
       * The previous version of the name if the action was `edited`.
       */
      from: string;
    };
    privacy?: {
      /**
       * The previous version of the team's privacy if the action was `edited`.
       */
      from: string;
    };
    repository?: {
      permissions: {
        from: {
          /**
           * The previous version of the team member's `admin` permission on a repository, if the action was `edited`.
           */
          admin?: boolean;
          /**
           * The previous version of the team member's `pull` permission on a repository, if the action was `edited`.
           */
          pull?: boolean;
          /**
           * The previous version of the team member's `push` permission on a repository, if the action was `edited`.
           */
          push?: boolean;
        };
      };
    };
  };
  team: Team;
  repository?: Repository;
  sender: User;
  organization: Organization;
}
export interface TeamRemovedFromRepositoryEvent {
  action: "removed_from_repository";
  team: Team;
  repository?: Repository;
  sender: User;
  organization: Organization;
}
export interface TeamAddEvent {
  team: Team;
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization: Organization;
}
export interface WatchStartedEvent {
  action: "started";
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
}
export interface WorkflowDispatchEvent {
  inputs: {
    [k: string]: unknown;
  };
  ref: string;
  repository: Repository;
  sender: User;
  installation?: InstallationLite;
  organization?: Organization;
  workflow: string;
}
export interface WorkflowRunCompletedEvent {
  action: "completed";
  organization?: Organization;
  repository: Repository;
  sender: User;
  workflow: Workflow;
  workflow_run: WorkflowRun & {
    conclusion: string;
  };
  installation?: InstallationLite;
}
export interface Workflow {
  badge_url: string;
  created_at: string;
  html_url: string;
  id: number;
  name: string;
  node_id: string;
  path: string;
  state: string;
  updated_at: string;
  url: string;
}
export interface WorkflowRun {
  artifacts_url: string;
  cancel_url: string;
  check_suite_url: string;
  check_suite_id?: number;
  conclusion: string | null;
  created_at: string;
  event: string;
  head_branch: string;
  head_commit: SimpleCommit;
  head_repository: RepositoryLite;
  head_sha: string;
  html_url: string;
  id: number;
  jobs_url: string;
  logs_url: string;
  node_id: string;
  pull_requests: PullRequest[];
  repository: RepositoryLite;
  rerun_url: string;
  run_number: number;
  status: string;
  updated_at: string;
  url: string;
  workflow_id: number;
  workflow_url: string;
}
export interface RepositoryLite {
  archive_url: string;
  assignees_url: string;
  blobs_url: string;
  branches_url: string;
  collaborators_url: string;
  comments_url: string;
  commits_url: string;
  compare_url: string;
  contents_url: string;
  contributors_url: string;
  deployments_url: string;
  description: string | null;
  downloads_url: string;
  events_url: string;
  fork: boolean;
  forks_url: string;
  full_name: string;
  git_commits_url: string;
  git_refs_url: string;
  git_tags_url: string;
  hooks_url: string;
  html_url: string;
  /**
   * Unique identifier of the repository
   */
  id: number;
  issue_comment_url: string;
  issue_events_url: string;
  issues_url: string;
  keys_url: string;
  labels_url: string;
  languages_url: string;
  merges_url: string;
  milestones_url: string;
  /**
   * The name of the repository.
   */
  name: string;
  node_id: string;
  notifications_url: string;
  owner: User;
  /**
   * Whether the repository is private or public.
   */
  private: boolean;
  pulls_url: string;
  releases_url: string;
  stargazers_url: string;
  statuses_url: string;
  subscribers_url: string;
  subscription_url: string;
  tags_url: string;
  teams_url: string;
  trees_url: string;
  url: string;
}
export interface WorkflowRunRequestedEvent {
  action: "requested";
  organization?: Organization;
  repository: Repository;
  sender: User;
  workflow: Workflow;
  workflow_run: WorkflowRun & {
    conclusion: null;
  };
  installation?: InstallationLite;
}

export interface EventPayloadMap {
  check_run: CheckRunEvent;
  check_suite: CheckSuiteEvent;
  code_scanning_alert: CodeScanningAlertEvent;
  commit_comment: CommitCommentEvent;
  content_reference: ContentReferenceEvent;
  create: CreateEvent;
  delete: DeleteEvent;
  deploy_key: DeployKeyEvent;
  deployment: DeploymentEvent;
  deployment_status: DeploymentStatusEvent;
  discussion: DiscussionEvent;
  discussion_comment: DiscussionCommentEvent;
  fork: ForkEvent;
  github_app_authorization: GithubAppAuthorizationEvent;
  gollum: GollumEvent;
  installation: InstallationEvent;
  installation_repositories: InstallationRepositoriesEvent;
  issue_comment: IssueCommentEvent;
  issues: IssuesEvent;
  label: LabelEvent;
  marketplace_purchase: MarketplacePurchaseEvent;
  member: MemberEvent;
  membership: MembershipEvent;
  meta: MetaEvent;
  milestone: MilestoneEvent;
  org_block: OrgBlockEvent;
  organization: OrganizationEvent;
  package: PackageEvent;
  page_build: PageBuildEvent;
  ping: PingEvent;
  project: ProjectEvent;
  project_card: ProjectCardEvent;
  project_column: ProjectColumnEvent;
  public: PublicEvent;
  pull_request: PullRequestEvent;
  pull_request_review: PullRequestReviewEvent;
  pull_request_review_comment: PullRequestReviewCommentEvent;
  push: PushEvent;
  release: ReleaseEvent;
  repository: RepositoryEvent;
  repository_dispatch: RepositoryDispatchEvent;
  repository_import: RepositoryImportEvent;
  repository_vulnerability_alert: RepositoryVulnerabilityAlertEvent;
  secret_scanning_alert: SecretScanningAlertEvent;
  security_advisory: SecurityAdvisoryEvent;
  sponsorship: SponsorshipEvent;
  star: StarEvent;
  status: StatusEvent;
  team: TeamEvent;
  team_add: TeamAddEvent;
  watch: WatchEvent;
  workflow_dispatch: WorkflowDispatchEvent;
  workflow_run: WorkflowRunEvent;
}

export type Asset = ReleaseAsset;
export type WebhookEvent = Schema;
export type WebhookEventMap = EventPayloadMap;
export type WebhookEventName = keyof EventPayloadMap;
