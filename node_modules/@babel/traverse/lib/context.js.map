{"version":3,"names":["_index","require","_t","_context","_hub","VISITOR_KEYS","TraversalContext","constructor","scope","opts","state","parentPath","queue","priorityQueue","shouldVisit","node","enter","exit","type","keys","length","key","create","container","listKey","hub","Hub","undefined","NodePath","get","parent","maybeQueue","path","notPriority","push","visitMultiple","visitQueue","visitSingle","visited","WeakSet","stop","visitIndex","resync","call","contexts","pushContext","has","add","visit","i","popContext","nodes","Array","isArray","exports","default"],"sources":["../src/context.ts"],"sourcesContent":["import NodePath from \"./path/index.ts\";\nimport { VISITOR_KEYS } from \"@babel/types\";\nimport type Scope from \"./scope/index.ts\";\nimport type { ExplodedTraverseOptions } from \"./index.ts\";\nimport type * as t from \"@babel/types\";\nimport type { Visitor } from \"./types.ts\";\nimport { popContext, pushContext, resync } from \"./path/context.ts\";\nimport Hub from \"./hub.ts\";\n\nexport default class TraversalContext<S = unknown> {\n  constructor(\n    scope: Scope | null | undefined,\n    opts: ExplodedTraverseOptions<S>,\n    state: S,\n    parentPath: NodePath | undefined,\n  ) {\n    this.parentPath = parentPath;\n    this.scope = scope;\n    this.state = state;\n    this.opts = opts;\n  }\n\n  declare parentPath: NodePath | undefined;\n  declare scope: Scope | null | undefined;\n  declare state: S;\n  declare opts: ExplodedTraverseOptions<S>;\n  queue: NodePath[] | null = null;\n  priorityQueue: NodePath[] | null = null;\n\n  /**\n   * This method does a simple check to determine whether or not we really need to attempt\n   * visit a node. This will prevent us from constructing a NodePath.\n   */\n\n  shouldVisit(node: t.Node): boolean {\n    const opts = this.opts as Visitor;\n    if (opts.enter || opts.exit) return true;\n\n    // check if we have a visitor for this node\n    if (opts[node.type]) return true;\n\n    // check if we're going to traverse into this node\n    const keys: string[] | undefined = VISITOR_KEYS[node.type];\n    if (!keys?.length) return false;\n\n    // we need to traverse into this node so ensure that it has children to traverse into!\n    for (const key of keys) {\n      if (\n        // @ts-expect-error key is from visitor keys\n        node[key]\n      ) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  create(\n    node: t.Node,\n    container: t.Node | t.Node[],\n    key: string | number,\n    listKey?: string,\n  ): NodePath {\n    const { parentPath } = this;\n    const hub =\n      parentPath == null\n        ? node.type === \"Program\" || node.type === \"File\"\n          ? new Hub()\n          : undefined\n        : parentPath.hub;\n\n    // We don't need to `.setContext()` here, since `.visitQueue()` already\n    // calls `.pushContext`.\n    return NodePath.get({\n      parentPath,\n      parent: node,\n      container,\n      key: key,\n      listKey,\n      hub,\n    });\n  }\n\n  maybeQueue(path: NodePath, notPriority?: boolean) {\n    if (this.queue) {\n      if (notPriority) {\n        this.queue.push(path);\n      } else {\n        this.priorityQueue!.push(path);\n      }\n    }\n  }\n\n  visitMultiple(container: t.Node[], parent: t.Node, listKey: string) {\n    // nothing to traverse!\n    if (container.length === 0) return false;\n\n    const queue = [];\n\n    // build up initial queue\n    for (let key = 0; key < container.length; key++) {\n      const node = container[key];\n      if (node && this.shouldVisit(node)) {\n        queue.push(this.create(parent, container, key, listKey));\n      }\n    }\n\n    return this.visitQueue(queue);\n  }\n\n  visitSingle(node: t.Node, key: string): boolean {\n    if (\n      this.shouldVisit(\n        // @ts-expect-error key may not index node\n        node[key],\n      )\n    ) {\n      return this.visitQueue([this.create(node, node, key)]);\n    } else {\n      return false;\n    }\n  }\n\n  visitQueue(queue: NodePath[]): boolean {\n    // set queue\n    this.queue = queue;\n    this.priorityQueue = [];\n\n    const visited = new WeakSet();\n    let stop = false;\n    let visitIndex = 0;\n\n    // visit the queue\n    for (; visitIndex < queue.length; ) {\n      const path = queue[visitIndex];\n      visitIndex++;\n      resync.call(path);\n\n      // this path no longer belongs to the tree\n      if (process.env.BABEL_8_BREAKING && path.key === null) continue;\n\n      if (\n        path.contexts.length === 0 ||\n        path.contexts[path.contexts.length - 1] !== this\n      ) {\n        // The context might already have been pushed when this path was inserted and queued.\n        // If we always re-pushed here, we could get duplicates and risk leaving contexts\n        // on the stack after the traversal has completed, which could break things.\n        pushContext.call(path, this);\n      }\n\n      // this path no longer belongs to the tree\n      if (!process.env.BABEL_8_BREAKING && path.key === null) continue;\n\n      // ensure we don't visit the same node twice\n      const { node } = path;\n      if (visited.has(node)) continue;\n      if (node) visited.add(node);\n\n      if (path.visit()) {\n        stop = true;\n        break;\n      }\n\n      if (this.priorityQueue.length) {\n        stop = this.visitQueue(this.priorityQueue);\n        this.priorityQueue = [];\n        this.queue = queue;\n        if (stop) break;\n      }\n    }\n\n    // pop contexts\n    for (let i = 0; i < visitIndex; i++) {\n      if (process.env.BABEL_8_BREAKING && queue[i].key === null) continue;\n      popContext.call(queue[i]);\n    }\n\n    // clear queue\n    this.queue = null;\n\n    return stop;\n  }\n\n  visit(node: t.Node, key: string) {\n    // @ts-expect-error key may not index node\n    const nodes = node[key] as t.Node | t.Node[] | null;\n    if (!nodes) return false;\n\n    if (Array.isArray(nodes)) {\n      return this.visitMultiple(nodes, node, key);\n    } else {\n      return this.visitSingle(node, key);\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]}