{"version":3,"names":["_t","require","_index","isIdentifier","_params","node","noLineTerminator","idNode","parentNode","print","typeParameters","undefined","nameInfo","_getFuncIdName","call","sourceIdentifierName","name","pos","token","_parameters","params","returnType","_noLineTerminator","parameters","endToken","oldNoLineTerminatorAfterNode","enterDelimited","trailingComma","shouldPrintTrailingComma","paramLength","length","i","_param","tokenChar","space","_noLineTerminatorAfterNode","parameter","printJoin","decorators","optional","typeAnnotation","_methodHead","kind","key","word","async","generator","computed","_buf","_map","type","_predicate","noLineTerminatorAfter","predicate","_functionHead","parent","hasPredicate","format","preserveFormat","_innerCommentsState","id","FunctionExpression","body","ArrowFunctionExpression","_shouldPrintArrowParamsParens","printInnerComments","tokenContext","TokenContext","arrowBody","_firstParam$leadingCo","_firstParam$trailingC","firstParam","leadingComments","trailingComments","tokenMap","loc","findMatching","arrowToken","start","line","retainLines","parentType","left","_id$loc","_id$loc2","identifierName","_id$loc3","_id$loc4","value"],"sources":["../../src/generators/methods.ts"],"sourcesContent":["import type Printer from \"../printer.ts\";\nimport type * as t from \"@babel/types\";\nimport { isIdentifier, type ParentMaps } from \"@babel/types\";\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport * as charCodes from \"charcodes\";\nimport { TokenContext } from \"../node/index.ts\";\n\ntype ParentsOf<T extends t.Node> = ParentMaps[T[\"type\"]];\n\nexport function _params(\n  this: Printer,\n  node: t.Function | t.TSDeclareMethod | t.TSDeclareFunction,\n  noLineTerminator: boolean,\n  idNode?: t.Expression | t.PrivateName | null,\n  parentNode?: ParentsOf<typeof node>,\n) {\n  this.print(node.typeParameters);\n\n  if (idNode !== undefined || parentNode !== undefined) {\n    const nameInfo = _getFuncIdName.call(this, idNode, parentNode);\n    if (nameInfo) {\n      this.sourceIdentifierName(nameInfo.name, nameInfo.pos);\n    }\n  }\n\n  this.token(\"(\");\n  _parameters.call(this, node.params, charCodes.rightParenthesis);\n\n  this.print(node.returnType, noLineTerminator);\n\n  this._noLineTerminator = noLineTerminator;\n}\n\nexport function _parameters(\n  this: Printer,\n  parameters: t.Function[\"params\"],\n  endToken: number,\n) {\n  const oldNoLineTerminatorAfterNode = this.enterDelimited();\n\n  const trailingComma = this.shouldPrintTrailingComma(endToken);\n\n  const paramLength = parameters.length;\n  for (let i = 0; i < paramLength; i++) {\n    _param.call(this, parameters[i]);\n\n    if (trailingComma || i < paramLength - 1) {\n      this.tokenChar(charCodes.comma, i);\n      this.space();\n    }\n  }\n\n  this.tokenChar(endToken);\n  this._noLineTerminatorAfterNode = oldNoLineTerminatorAfterNode;\n}\n\nexport function _param(\n  this: Printer,\n  parameter: t.Identifier | t.RestElement | t.Pattern | t.TSParameterProperty,\n) {\n  this.printJoin(\n    // @ts-expect-error decorators is not in VoidPattern\n    parameter.decorators,\n    undefined,\n    undefined,\n    undefined,\n    undefined,\n    true,\n  );\n  this.print(parameter, undefined, true);\n  if (\n    // @ts-expect-error optional is not in TSParameterProperty\n    parameter.optional\n  ) {\n    this.token(\"?\"); // TS / flow\n  }\n\n  this.print(\n    // @ts-expect-error typeAnnotation is not in TSParameterProperty\n    parameter.typeAnnotation,\n    undefined,\n    true,\n  ); // TS / flow\n}\n\nexport function _methodHead(this: Printer, node: t.Method | t.TSDeclareMethod) {\n  const kind = node.kind;\n  const key = node.key;\n\n  if (kind === \"get\" || kind === \"set\") {\n    this.word(kind);\n    this.space();\n  }\n\n  if (node.async) {\n    this.word(\"async\", true);\n    this.space();\n  }\n\n  if (\n    kind === \"method\" ||\n    // @ts-expect-error Fixme: kind: \"init\" is not defined\n    kind === \"init\"\n  ) {\n    if (node.generator) {\n      this.token(\"*\");\n    }\n  }\n\n  if (node.computed) {\n    this.token(\"[\");\n    this.print(key);\n    this.token(\"]\");\n  } else {\n    this.print(key);\n  }\n\n  if (\n    // @ts-expect-error optional is not in ObjectMethod\n    node.optional\n  ) {\n    // TS\n    this.token(\"?\");\n  }\n\n  if (this._buf._map) {\n    _params.call(\n      this,\n      node,\n      false,\n      node.computed && node.key.type !== \"StringLiteral\" ? undefined : node.key,\n    );\n  } else {\n    _params.call(this, node, false);\n  }\n}\n\nexport function _predicate(\n  this: Printer,\n  node:\n    | t.FunctionDeclaration\n    | t.FunctionExpression\n    | t.ArrowFunctionExpression,\n  noLineTerminatorAfter?: boolean,\n) {\n  if (node.predicate) {\n    if (!node.returnType) {\n      this.token(\":\");\n    }\n    this.space();\n    this.print(node.predicate, noLineTerminatorAfter);\n  }\n}\n\nexport function _functionHead(\n  this: Printer,\n  node: t.FunctionDeclaration | t.FunctionExpression | t.TSDeclareFunction,\n  parent: ParentsOf<typeof node>,\n  hasPredicate: boolean,\n) {\n  if (node.async) {\n    this.word(\"async\");\n    if (!this.format.preserveFormat) {\n      // We prevent inner comments from being printed here,\n      // so that they are always consistently printed in the\n      // same place regardless of the function type.\n      this._innerCommentsState = 0 /* INNER_COMMENT_STATE.DISALLOWED */;\n    }\n    this.space();\n  }\n  this.word(\"function\");\n  if (node.generator) {\n    if (!this.format.preserveFormat) {\n      // We prevent inner comments from being printed here,\n      // so that they are always consistently printed in the\n      // same place regardless of the function type.\n      this._innerCommentsState = 0 /* INNER_COMMENT_STATE.DISALLOWED */;\n    }\n    this.token(\"*\");\n  }\n\n  this.space();\n  if (node.id) {\n    this.print(node.id);\n  }\n\n  if (this._buf._map) {\n    _params.call(this, node, false, node.id, parent);\n  } else {\n    _params.call(this, node, false);\n  }\n  if (hasPredicate) {\n    _predicate.call(this, node as t.FunctionDeclaration | t.FunctionExpression);\n  }\n}\n\nexport function FunctionExpression(\n  this: Printer,\n  node: t.FunctionExpression,\n  parent: ParentsOf<typeof node>,\n) {\n  _functionHead.call(this, node, parent, true);\n  this.space();\n  this.print(node.body);\n}\n\nexport { FunctionExpression as FunctionDeclaration };\n\nexport function ArrowFunctionExpression(\n  this: Printer,\n  node: t.ArrowFunctionExpression,\n  parent: ParentsOf<typeof node>,\n) {\n  if (node.async) {\n    this.word(\"async\", true);\n    this.space();\n  }\n\n  if (_shouldPrintArrowParamsParens.call(this, node)) {\n    _params.call(\n      this,\n      node,\n      true,\n      undefined,\n      this._buf._map ? parent : undefined,\n    );\n  } else {\n    this.print(node.params[0], true);\n  }\n\n  _predicate.call(this, node, true);\n  this.space();\n  // When printing (x)/*1*/=>{}, we remove the parentheses\n  // and thus there aren't two contiguous inner tokens.\n  // We forcefully print inner comments here.\n  this.printInnerComments();\n  this.token(\"=>\");\n\n  this.space();\n\n  this.tokenContext |= TokenContext.arrowBody;\n  this.print(node.body);\n}\n\n// Try to avoid printing parens in simple cases, but only if we're pretty\n// sure that they aren't needed by type annotations or potential newlines.\nexport function _shouldPrintArrowParamsParens(\n  this: Printer,\n  node: t.ArrowFunctionExpression,\n): boolean {\n  if (node.params.length !== 1) return true;\n\n  if (node.typeParameters || node.returnType || node.predicate) {\n    return true;\n  }\n\n  const firstParam = node.params[0];\n  if (\n    !isIdentifier(firstParam) ||\n    firstParam.typeAnnotation ||\n    firstParam.optional ||\n    // Flow does not support `foo /*: string*/ => {};`\n    firstParam.leadingComments?.length ||\n    firstParam.trailingComments?.length\n  ) {\n    return true;\n  }\n\n  if (this.tokenMap) {\n    if (node.loc == null) return true;\n    if (this.tokenMap.findMatching(node, \"(\") !== null) return true;\n    const arrowToken = this.tokenMap.findMatching(node, \"=>\");\n    if (arrowToken?.loc == null) return true;\n    return arrowToken.loc.start.line !== node.loc.start.line;\n  }\n\n  if (this.format.retainLines) return true;\n\n  return false;\n}\n\nfunction _getFuncIdName(\n  this: Printer,\n  idNode: t.Expression | t.PrivateName,\n  parent: ParentsOf<t.Function | t.TSDeclareMethod | t.TSDeclareFunction>,\n) {\n  let id: t.Expression | t.PrivateName | t.LVal | t.VoidPattern = idNode;\n\n  if (!id && parent) {\n    const parentType = parent.type;\n\n    if (parentType === \"VariableDeclarator\") {\n      id = parent.id;\n    } else if (\n      parentType === \"AssignmentExpression\" ||\n      parentType === \"AssignmentPattern\"\n    ) {\n      id = parent.left;\n    } else if (\n      parentType === \"ObjectProperty\" ||\n      parentType === \"ClassProperty\"\n    ) {\n      if (!parent.computed || parent.key.type === \"StringLiteral\") {\n        id = parent.key;\n      }\n    } else if (\n      parentType === \"ClassPrivateProperty\" ||\n      parentType === \"ClassAccessorProperty\"\n    ) {\n      id = parent.key;\n    }\n  }\n\n  if (!id) return;\n\n  let nameInfo;\n\n  if (id.type === \"Identifier\") {\n    nameInfo = {\n      pos: id.loc?.start,\n      name: id.loc?.identifierName || id.name,\n    };\n  } else if (id.type === \"PrivateName\") {\n    nameInfo = {\n      pos: id.loc?.start,\n      name: \"#\" + id.id.name,\n    };\n  } else if (id.type === \"StringLiteral\") {\n    nameInfo = {\n      pos: id.loc?.start,\n      name: id.value,\n    };\n  }\n\n  return nameInfo;\n}\n"],"mappings":"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","ignoreList":[]}