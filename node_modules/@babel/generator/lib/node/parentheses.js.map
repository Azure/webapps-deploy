{"version":3,"names":["_t","require","_index","isMemberExpression","isOptionalMemberExpression","isYieldExpression","isStatement","PRECEDENCE","Map","isTSTypeExpression","nodeId","isClassExtendsClause","node","parent","parentId","superClass","hasPostfixPart","object","callee","tag","NullableTypeAnnotation","FunctionTypeAnnotation","tokenContext","TokenContext","arrowFlowReturnType","UpdateExpression","needsParenBeforeExpressionBrace","expressionStatement","arrowBody","ObjectExpression","DoExpression","async","BinaryLike","nodeType","parentPos","get","operator","undefined","nodePos","left","right","UnionTypeAnnotation","OptionalIndexedAccessType","objectType","TSAsExpression","TSConditionalType","types","checkType","extendsType","TSUnionType","TSIntersectionType","TSTypeOperator","TSInferType","typeParameter","constraint","TSInstantiationExpression","typeParameters","TSFunctionType","BinaryExpression","forInOrInitHeadAccumulate","LogicalExpression","SequenceExpression","property","YieldExpression","test","ClassExpression","exportDefault","UnaryLike","FunctionExpression","ConditionalExpression","OptionalMemberExpression","AssignmentExpression","type","Identifier","getRawIdentifier","_node$extra","name","extra","parenthesized","rightType","id","forOfHead","forInitHead","forInHead","isFollowedByBracket","computed","optional","await"],"sources":["../../src/node/parentheses.ts"],"sourcesContent":["import {\n  isMemberExpression,\n  isOptionalMemberExpression,\n  isYieldExpression,\n  isStatement,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\n\nimport { TokenContext } from \"./index.ts\";\n\nconst PRECEDENCE = new Map([\n  [\"||\", 0],\n  [\"??\", 1],\n  [\"&&\", 2],\n  [\"|\", 3],\n  [\"^\", 4],\n  [\"&\", 5],\n  [\"==\", 6],\n  [\"===\", 6],\n  [\"!=\", 6],\n  [\"!==\", 6],\n  [\"<\", 7],\n  [\">\", 7],\n  [\"<=\", 7],\n  [\">=\", 7],\n  [\"in\", 7],\n  [\"instanceof\", 7],\n  [\">>\", 8],\n  [\"<<\", 8],\n  [\">>>\", 8],\n  [\"+\", 9],\n  [\"-\", 9],\n  [\"*\", 10],\n  [\"/\", 10],\n  [\"%\", 10],\n  [\"**\", 11],\n]);\n\nfunction isTSTypeExpression(nodeId: number) {\n  return (\n    nodeId === __node(\"TSAsExpression\") ||\n    nodeId === __node(\"TSSatisfiesExpression\") ||\n    nodeId === __node(\"TSTypeAssertion\")\n  );\n}\n\nconst isClassExtendsClause = (\n  node: t.Node,\n  parent: any,\n  parentId: number,\n): parent is t.Class => {\n  return (\n    (parentId === __node(\"ClassDeclaration\") ||\n      parentId === __node(\"ClassExpression\")) &&\n    parent.superClass === node\n  );\n};\n\nconst hasPostfixPart = (node: t.Node, parent: any, parentId: number) => {\n  switch (parentId) {\n    case __node(\"MemberExpression\"):\n    case __node(\"OptionalMemberExpression\"):\n      return parent.object === node;\n    case __node(\"CallExpression\"):\n    case __node(\"OptionalCallExpression\"):\n    case __node(\"NewExpression\"):\n      return parent.callee === node;\n    case __node(\"TaggedTemplateExpression\"):\n      return parent.tag === node;\n    case __node(\"TSNonNullExpression\"):\n      return true;\n  }\n\n  return false;\n};\n\nexport function NullableTypeAnnotation(\n  node: t.NullableTypeAnnotation,\n  parent: any,\n  parentId: number,\n): boolean {\n  return parentId === __node(\"ArrayTypeAnnotation\");\n}\n\nexport function FunctionTypeAnnotation(\n  node: t.FunctionTypeAnnotation,\n  parent: any,\n  parentId: number,\n  tokenContext: number,\n): boolean {\n  return (\n    // (() => A) | (() => B)\n    parentId === __node(\"UnionTypeAnnotation\") ||\n    // (() => A) & (() => B)\n    parentId === __node(\"IntersectionTypeAnnotation\") ||\n    // (() => A)[]\n    parentId === __node(\"ArrayTypeAnnotation\") ||\n    (tokenContext & TokenContext.arrowFlowReturnType) > 0\n  );\n}\n\nexport function UpdateExpression(\n  node: t.UpdateExpression,\n  parent: any,\n  parentId: number,\n): boolean {\n  return (\n    hasPostfixPart(node, parent, parentId) ||\n    isClassExtendsClause(node, parent, parentId)\n  );\n}\n\nfunction needsParenBeforeExpressionBrace(tokenContext: number) {\n  return (\n    (tokenContext &\n      (TokenContext.expressionStatement | TokenContext.arrowBody)) >\n    0\n  );\n}\n\nexport function ObjectExpression(\n  node: t.ObjectExpression,\n  parent: any,\n  parentId: number,\n  tokenContext: number,\n): boolean {\n  return needsParenBeforeExpressionBrace(tokenContext);\n}\n\nexport function DoExpression(\n  node: t.DoExpression,\n  parent: any,\n  parentId: number,\n  tokenContext: number,\n): boolean {\n  // `async do` can start an expression statement\n  return (tokenContext & TokenContext.expressionStatement) > 0 && !node.async;\n}\n\nconst enum BinaryLikeType {\n  Binary = 0,\n  Logical = 1,\n  TypeScript = 2,\n}\n\nfunction BinaryLike(\n  node: t.Binary | t.TSAsExpression | t.TSSatisfiesExpression,\n  parent: any,\n  parentId: number,\n  nodeType: BinaryLikeType,\n): boolean {\n  if (isClassExtendsClause(node, parent, parentId)) {\n    return true;\n  }\n\n  if (\n    hasPostfixPart(node, parent, parentId) ||\n    parentId === __node(\"UnaryExpression\") ||\n    parentId === __node(\"SpreadElement\") ||\n    parentId === __node(\"AwaitExpression\")\n  ) {\n    return true;\n  }\n  let parentPos: number | undefined;\n  switch (parentId) {\n    case __node(\"BinaryExpression\"):\n    case __node(\"LogicalExpression\"):\n      parentPos = PRECEDENCE.get(parent.operator);\n      break;\n    case __node(\"TSAsExpression\"):\n    case __node(\"TSSatisfiesExpression\"):\n      parentPos = 7; /* in */\n  }\n  if (parentPos !== undefined) {\n    const nodePos =\n      nodeType === BinaryLikeType.TypeScript\n        ? 7 /* in */\n        : PRECEDENCE.get((node as t.Binary).operator)!;\n    if (parentPos > nodePos) return true;\n    if (\n      parentPos === nodePos &&\n      parentId === __node(\"BinaryExpression\") &&\n      (nodePos === 11 /* ** */ ? parent.left === node : parent.right === node)\n    ) {\n      return true;\n    }\n    if (\n      nodeType === BinaryLikeType.Logical &&\n      parentId === __node(\"LogicalExpression\") &&\n      // 1: ??\n      ((nodePos === 1 && parentPos !== 1) || (parentPos === 1 && nodePos !== 1))\n    ) {\n      return true;\n    }\n  }\n  return false;\n}\n\nexport function UnionTypeAnnotation(\n  node: t.UnionTypeAnnotation | t.IntersectionTypeAnnotation,\n  parent: any,\n  parentId: number,\n): boolean {\n  switch (parentId) {\n    case __node(\"ArrayTypeAnnotation\"):\n    case __node(\"NullableTypeAnnotation\"):\n    case __node(\"IntersectionTypeAnnotation\"):\n    case __node(\"UnionTypeAnnotation\"):\n      return true;\n  }\n  return false;\n}\n\nexport { UnionTypeAnnotation as IntersectionTypeAnnotation };\n\nexport function OptionalIndexedAccessType(\n  node: t.OptionalIndexedAccessType,\n  parent: any,\n  parentId: number,\n): boolean {\n  return parentId === __node(\"IndexedAccessType\") && parent.objectType === node;\n}\n\nexport function TSAsExpression(\n  node: t.TSAsExpression | t.TSSatisfiesExpression,\n  parent: any,\n  parentId: number,\n): boolean {\n  if (\n    (parentId === __node(\"AssignmentExpression\") ||\n      parentId === __node(\"AssignmentPattern\")) &&\n    parent.left === node\n  ) {\n    return true;\n  }\n  if (\n    parentId === __node(\"BinaryExpression\") &&\n    (parent.operator === \"|\" || parent.operator === \"&\") &&\n    node === parent.left\n  ) {\n    return true;\n  }\n  return BinaryLike(node, parent, parentId, BinaryLikeType.TypeScript);\n}\n\nexport { TSAsExpression as TSSatisfiesExpression };\n\nexport { UnaryLike as TSTypeAssertion };\n\nexport function TSConditionalType(\n  node: t.TSConditionalType,\n  parent: any,\n  parentId: number,\n): boolean {\n  switch (parentId) {\n    case __node(\"TSArrayType\"):\n    case __node(\"TSOptionalType\"):\n    case __node(\"TSTypeOperator\"):\n    // for `infer K extends (L extends M ? M : ...)`\n    // fallthrough\n    case __node(\"TSTypeParameter\"):\n      return true;\n    case __node(\"TSIndexedAccessType\"):\n      return parent.objectType === node;\n    case __node(\"TSIntersectionType\"):\n    case __node(\"TSUnionType\"):\n      return parent.types[0] === node;\n    case __node(\"TSConditionalType\"):\n      return parent.checkType === node || parent.extendsType === node;\n  }\n  return false;\n}\n\nexport function TSUnionType(\n  node: t.TSUnionType | t.TSFunctionType,\n  parent: any,\n  parentId: number,\n): boolean {\n  switch (parentId) {\n    case __node(\"TSIntersectionType\"):\n    case __node(\"TSTypeOperator\"):\n    case __node(\"TSArrayType\"):\n    case __node(\"TSOptionalType\"):\n      return true;\n    case __node(\"TSIndexedAccessType\"):\n      return parent.objectType === node;\n  }\n  return false;\n}\n\nexport function TSIntersectionType(\n  node: t.TSUnionType,\n  parent: any,\n  parentId: number,\n): boolean {\n  return (\n    parentId === __node(\"TSTypeOperator\") ||\n    TSTypeOperator(node, parent, parentId)\n  );\n}\n\nexport function TSInferType(\n  node: t.TSInferType,\n  parent: any,\n  parentId: number,\n): boolean {\n  if (TSTypeOperator(node, parent, parentId)) {\n    return true;\n  }\n  if (\n    (parentId === __node(\"TSIntersectionType\") ||\n      parentId === __node(\"TSUnionType\")) &&\n    node.typeParameter.constraint &&\n    parent.types[0] === node\n  ) {\n    return true;\n  }\n  return false;\n}\n\nexport function TSTypeOperator(\n  node: t.TSTypeOperator | t.TSUnionType | t.TSInferType,\n  parent: any,\n  parentId: number,\n): boolean {\n  switch (parentId) {\n    case __node(\"TSArrayType\"):\n    case __node(\"TSOptionalType\"):\n      return true;\n    case __node(\"TSIndexedAccessType\"):\n      if (parent.objectType === node) {\n        return true;\n      }\n  }\n  return false;\n}\n\nexport function TSInstantiationExpression(\n  node: t.TSInstantiationExpression,\n  parent: any,\n  parentId: number,\n) {\n  switch (parentId) {\n    case __node(\"CallExpression\"):\n    case __node(\"OptionalCallExpression\"):\n    case __node(\"NewExpression\"):\n    case __node(\"TSInstantiationExpression\"):\n      return (\n        (process.env.BABEL_8_BREAKING\n          ? // @ts-ignore(Babel 7 vs Babel 8) Babel 8 AST\n            parent.typeArguments\n          : // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST\n            parent.typeParameters) != null\n      );\n  }\n\n  return false;\n}\n\nexport function TSFunctionType(\n  node: t.TSFunctionType,\n  parent: any,\n  parentId: number,\n): boolean {\n  if (TSUnionType(node, parent, parentId)) return true;\n\n  return (\n    parentId === __node(\"TSUnionType\") ||\n    (parentId === __node(\"TSConditionalType\") &&\n      (parent.checkType === node || parent.extendsType === node))\n  );\n}\n\nexport { TSFunctionType as TSConstructorType };\n\nexport function BinaryExpression(\n  node: t.BinaryExpression,\n  parent: any,\n  parentId: number,\n  tokenContext: number,\n): boolean {\n  if (BinaryLike(node, parent, parentId, BinaryLikeType.Binary)) return true;\n\n  // for ((1 in []);;);\n  // for (var x = (1 in []) in 2);\n  return (\n    (tokenContext & TokenContext.forInOrInitHeadAccumulate) > 0 &&\n    node.operator === \"in\"\n  );\n}\n\nexport function LogicalExpression(\n  node: t.LogicalExpression,\n  parent: any,\n  parentId: number,\n): boolean {\n  return BinaryLike(node, parent, parentId, BinaryLikeType.Logical);\n}\n\nexport function SequenceExpression(\n  node: t.SequenceExpression,\n  parent: any,\n  parentId: number,\n): boolean {\n  if (\n    parentId === __node(\"SequenceExpression\") ||\n    parentId === __node(\"ParenthesizedExpression\") ||\n    (parentId === __node(\"MemberExpression\") && parent.property === node) ||\n    (parentId === __node(\"OptionalMemberExpression\") &&\n      parent.property === node) ||\n    parentId === __node(\"TemplateLiteral\")\n  ) {\n    return false;\n  }\n  if (parentId === __node(\"ClassDeclaration\")) {\n    return true;\n  }\n  if (parentId === __node(\"ForOfStatement\")) {\n    return parent.right === node;\n  }\n  if (parentId === __node(\"ExportDefaultDeclaration\")) {\n    return true;\n  }\n\n  return !isStatement(parent);\n}\n\nexport function YieldExpression(\n  node: t.YieldExpression,\n  parent: any,\n  parentId: number,\n): boolean {\n  return (\n    parentId === __node(\"BinaryExpression\") ||\n    parentId === __node(\"LogicalExpression\") ||\n    parentId === __node(\"UnaryExpression\") ||\n    parentId === __node(\"SpreadElement\") ||\n    hasPostfixPart(node, parent, parentId) ||\n    (parentId === __node(\"AwaitExpression\") && isYieldExpression(node)) ||\n    (parentId === __node(\"ConditionalExpression\") && node === parent.test) ||\n    isClassExtendsClause(node, parent, parentId) ||\n    isTSTypeExpression(parentId)\n  );\n}\n\nexport { YieldExpression as AwaitExpression };\n\nexport function ClassExpression(\n  node: t.ClassExpression,\n  parent: any,\n  parentId: number,\n  tokenContext: number,\n): boolean {\n  return (\n    (tokenContext &\n      (TokenContext.expressionStatement | TokenContext.exportDefault)) >\n    0\n  );\n}\n\nfunction UnaryLike(\n  node:\n    | t.UnaryLike\n    | t.TSTypeAssertion\n    | t.ArrowFunctionExpression\n    | t.ConditionalExpression\n    | t.AssignmentExpression,\n  parent: any,\n  parentId: number,\n): boolean {\n  return (\n    hasPostfixPart(node, parent, parentId) ||\n    (parentId === __node(\"BinaryExpression\") &&\n      parent.operator === \"**\" &&\n      parent.left === node) ||\n    isClassExtendsClause(node, parent, parentId)\n  );\n}\n\nexport { UnaryLike as UnaryExpression, UnaryLike as SpreadElement };\n\nexport function FunctionExpression(\n  node: t.FunctionExpression,\n  parent: any,\n  parentId: number,\n  tokenContext: number,\n): boolean {\n  return (\n    (tokenContext &\n      (TokenContext.expressionStatement | TokenContext.exportDefault)) >\n    0\n  );\n}\n\nexport function ConditionalExpression(\n  node:\n    | t.ConditionalExpression\n    | t.ArrowFunctionExpression\n    | t.AssignmentExpression,\n  parent: any,\n  parentId: number,\n): boolean {\n  switch (parentId) {\n    case __node(\"UnaryExpression\"):\n    case __node(\"SpreadElement\"):\n    case __node(\"BinaryExpression\"):\n    case __node(\"LogicalExpression\"):\n    case __node(\"AwaitExpression\"):\n      return true;\n    case __node(\"ConditionalExpression\"):\n      if (parent.test === node) {\n        return true;\n      }\n  }\n\n  if (isTSTypeExpression(parentId)) {\n    return true;\n  }\n\n  return UnaryLike(node, parent, parentId);\n}\n\nexport { ConditionalExpression as ArrowFunctionExpression };\n\nexport function OptionalMemberExpression(\n  node: t.OptionalMemberExpression,\n  parent: any,\n  parentId: number,\n): boolean {\n  switch (parentId) {\n    case __node(\"CallExpression\"):\n      return parent.callee === node;\n    case __node(\"MemberExpression\"):\n      return parent.object === node;\n  }\n  return false;\n}\n\nexport { OptionalMemberExpression as OptionalCallExpression };\n\nexport function AssignmentExpression(\n  node: t.AssignmentExpression,\n  parent: any,\n  parentId: number,\n  tokenContext: number,\n): boolean {\n  if (\n    needsParenBeforeExpressionBrace(tokenContext) &&\n    node.left.type === \"ObjectPattern\"\n  ) {\n    return true;\n  }\n  return ConditionalExpression(node, parent, parentId);\n}\n\nexport function Identifier(\n  node: t.Identifier,\n  parent: any,\n  parentId: number,\n  tokenContext: number,\n  getRawIdentifier: (node: t.Identifier) => string,\n): boolean {\n  if (getRawIdentifier && getRawIdentifier(node) !== node.name) {\n    return false;\n  }\n\n  // 13.15.2 AssignmentExpression RS: Evaluation\n  // (fn) = function () {};\n  if (\n    parentId === __node(\"AssignmentExpression\") &&\n    node.extra?.parenthesized &&\n    parent.left === node\n  ) {\n    const rightType = parent.right.type;\n    if (\n      (rightType === \"FunctionExpression\" || rightType === \"ClassExpression\") &&\n      parent.right.id == null\n    ) {\n      return true;\n    }\n  }\n\n  // fast path\n  if (\n    tokenContext & TokenContext.forOfHead ||\n    ((parentId === __node(\"MemberExpression\") ||\n      parentId === __node(\"OptionalMemberExpression\")) &&\n      tokenContext &\n        (TokenContext.expressionStatement |\n          TokenContext.forInitHead |\n          TokenContext.forInHead))\n  ) {\n    // Non-strict code allows the identifier `let`, but it cannot occur as-is in\n    // certain contexts to avoid ambiguity with contextual keyword `let`.\n    if (node.name === \"let\") {\n      // Some contexts only forbid `let [`, so check if the next token would\n      // be the left bracket of a computed member expression.\n      const isFollowedByBracket =\n        isMemberExpression(parent, {\n          object: node,\n          computed: true,\n        }) ||\n        isOptionalMemberExpression(parent, {\n          object: node,\n          computed: true,\n          optional: false,\n        });\n      if (\n        isFollowedByBracket &&\n        tokenContext &\n          (TokenContext.expressionStatement |\n            TokenContext.forInitHead |\n            TokenContext.forInHead)\n      ) {\n        return true;\n      }\n      return (tokenContext & TokenContext.forOfHead) > 0;\n    }\n  }\n\n  // ECMAScript specifically forbids a for-of loop from starting with the\n  // token sequence `for (async of`, because it would be ambiguous with\n  // `for (async of => {};;)`, so we need to add extra parentheses.\n  return (\n    parentId === __node(\"ForOfStatement\") &&\n    parent.left === node &&\n    node.name === \"async\" &&\n    !parent.await\n  );\n}\n"],"mappings":"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","ignoreList":[]}