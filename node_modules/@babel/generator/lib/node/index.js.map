{"version":3,"names":["parens","require","_t","_nodes","VISITOR_KEYS","TokenContext","exports","normal","expressionStatement","arrowBody","exportDefault","arrowFlowReturnType","forInitHead","forInHead","forOfHead","forInOrInitHeadAccumulate","forInOrInitHeadAccumulatePassThroughMask","type","Object","keys","func","generatorInfosMap","has","get","isOrHasCallExpression","node","object","parentNeedsParens","parent","parentId","callee","isDecoratorMemberExpression","computed","property","isLastChild","child","visitorKeys","i","length","val","Array","isArray","j"],"sources":["../../src/node/index.ts"],"sourcesContent":["import * as parens from \"./parentheses.ts\";\nimport { VISITOR_KEYS } from \"@babel/types\";\nimport type * as t from \"@babel/types\";\n\nimport { generatorInfosMap } from \"../nodes.ts\";\n\nexport const enum TokenContext {\n  normal = 0,\n  expressionStatement = 1 << 0,\n  arrowBody = 1 << 1,\n  exportDefault = 1 << 2,\n  arrowFlowReturnType = 1 << 3,\n  forInitHead = 1 << 4,\n  forInHead = 1 << 5,\n  forOfHead = 1 << 6,\n  // This flag lives across the token boundary, and will\n  // be reset after forIn or forInit head is printed\n  forInOrInitHeadAccumulate = 1 << 7,\n  forInOrInitHeadAccumulatePassThroughMask = 0b10000000,\n}\n\nexport type NodeHandler<R> = (\n  node: t.Node,\n  // todo:\n  // node: K extends keyof typeof t\n  //   ? Extract<typeof t[K], { type: \"string\" }>\n  //   : t.Node,\n  parent: t.Node,\n  parentId: number,\n  tokenContext?: number,\n  getRawIdentifier?: (node: t.Identifier) => string,\n) => R | undefined;\n\nfor (const type of Object.keys(parens) as (keyof typeof parens)[]) {\n  const func = parens[type];\n  if (generatorInfosMap.has(type)) {\n    generatorInfosMap.get(type)![2] = func;\n  }\n}\n\nfunction isOrHasCallExpression(node: t.Node): boolean {\n  switch (node.type) {\n    case \"CallExpression\":\n      return true;\n    case \"MemberExpression\":\n      return isOrHasCallExpression(node.object);\n  }\n  return false;\n}\n\nexport function parentNeedsParens(\n  node: t.Node,\n  parent: any,\n  parentId: number,\n): boolean {\n  switch (parentId) {\n    case __node(\"NewExpression\"):\n      if (parent.callee === node) {\n        if (isOrHasCallExpression(node)) return true;\n      }\n      break;\n    case __node(\"Decorator\"):\n      return (\n        !isDecoratorMemberExpression(node) &&\n        !(\n          node.type === \"CallExpression\" &&\n          isDecoratorMemberExpression(node.callee)\n        ) &&\n        node.type !== \"ParenthesizedExpression\"\n      );\n  }\n  return false;\n}\n\nfunction isDecoratorMemberExpression(node: t.Node): boolean {\n  switch (node.type) {\n    case \"Identifier\":\n      return true;\n    case \"MemberExpression\":\n      return (\n        !node.computed &&\n        node.property.type === \"Identifier\" &&\n        isDecoratorMemberExpression(node.object)\n      );\n    default:\n      return false;\n  }\n}\n\nexport function isLastChild(parent: t.Node, child: t.Node) {\n  const visitorKeys = VISITOR_KEYS[parent.type];\n  for (let i = visitorKeys.length - 1; i >= 0; i--) {\n    const val = (parent as any)[visitorKeys[i]] as t.Node | t.Node[] | null;\n    if (val === child) {\n      return true;\n    } else if (Array.isArray(val)) {\n      let j = val.length - 1;\n      while (j >= 0 && val[j] === null) j--;\n      return j >= 0 && val[j] === child;\n    } else if (val) {\n      return false;\n    }\n  }\n  return false;\n}\n"],"mappings":";;;;;;;;AAAA,IAAAA,MAAA,GAAAC,OAAA;AACA,IAAAC,EAAA,GAAAD,OAAA;AAGA,IAAAE,MAAA,GAAAF,OAAA;AAAgD;EAHvCG;AAAY,IAAAF,EAAA;AAAA,MAKHG,YAAY,GAAAC,OAAA,CAAAD,YAAA;EAAAE,MAAA;EAAAC,mBAAA;EAAAC,SAAA;EAAAC,aAAA;EAAAC,mBAAA;EAAAC,WAAA;EAAAC,SAAA;EAAAC,SAAA;EAAAC,yBAAA;EAAAC,wCAAA;AAAA;AA2B9B,KAAK,MAAMC,IAAI,IAAIC,MAAM,CAACC,IAAI,CAACnB,MAAM,CAAC,EAA6B;EACjE,MAAMoB,IAAI,GAAGpB,MAAM,CAACiB,IAAI,CAAC;EACzB,IAAII,wBAAiB,CAACC,GAAG,CAACL,IAAI,CAAC,EAAE;IAC/BI,wBAAiB,CAACE,GAAG,CAACN,IAAI,CAAC,CAAE,CAAC,CAAC,GAAGG,IAAI;EACxC;AACF;AAEA,SAASI,qBAAqBA,CAACC,IAAY,EAAW;EACpD,QAAQA,IAAI,CAACR,IAAI;IACf,KAAK,gBAAgB;MACnB,OAAO,IAAI;IACb,KAAK,kBAAkB;MACrB,OAAOO,qBAAqB,CAACC,IAAI,CAACC,MAAM,CAAC;EAC7C;EACA,OAAO,KAAK;AACd;AAEO,SAASC,iBAAiBA,CAC/BF,IAAY,EACZG,MAAW,EACXC,QAAgB,EACP;EACT,QAAQA,QAAQ;IACd;MACE,IAAID,MAAM,CAACE,MAAM,KAAKL,IAAI,EAAE;QAC1B,IAAID,qBAAqB,CAACC,IAAI,CAAC,EAAE,OAAO,IAAI;MAC9C;MACA;IACF;MACE,OACE,CAACM,2BAA2B,CAACN,IAAI,CAAC,IAClC,EACEA,IAAI,CAACR,IAAI,KAAK,gBAAgB,IAC9Bc,2BAA2B,CAACN,IAAI,CAACK,MAAM,CAAC,CACzC,IACDL,IAAI,CAACR,IAAI,KAAK,yBAAyB;EAE7C;EACA,OAAO,KAAK;AACd;AAEA,SAASc,2BAA2BA,CAACN,IAAY,EAAW;EAC1D,QAAQA,IAAI,CAACR,IAAI;IACf,KAAK,YAAY;MACf,OAAO,IAAI;IACb,KAAK,kBAAkB;MACrB,OACE,CAACQ,IAAI,CAACO,QAAQ,IACdP,IAAI,CAACQ,QAAQ,CAAChB,IAAI,KAAK,YAAY,IACnCc,2BAA2B,CAACN,IAAI,CAACC,MAAM,CAAC;IAE5C;MACE,OAAO,KAAK;EAChB;AACF;AAEO,SAASQ,WAAWA,CAACN,MAAc,EAAEO,KAAa,EAAE;EACzD,MAAMC,WAAW,GAAGhC,YAAY,CAACwB,MAAM,CAACX,IAAI,CAAC;EAC7C,KAAK,IAAIoB,CAAC,GAAGD,WAAW,CAACE,MAAM,GAAG,CAAC,EAAED,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;IAChD,MAAME,GAAG,GAAIX,MAAM,CAASQ,WAAW,CAACC,CAAC,CAAC,CAA6B;IACvE,IAAIE,GAAG,KAAKJ,KAAK,EAAE;MACjB,OAAO,IAAI;IACb,CAAC,MAAM,IAAIK,KAAK,CAACC,OAAO,CAACF,GAAG,CAAC,EAAE;MAC7B,IAAIG,CAAC,GAAGH,GAAG,CAACD,MAAM,GAAG,CAAC;MACtB,OAAOI,CAAC,IAAI,CAAC,IAAIH,GAAG,CAACG,CAAC,CAAC,KAAK,IAAI,EAAEA,CAAC,EAAE;MACrC,OAAOA,CAAC,IAAI,CAAC,IAAIH,GAAG,CAACG,CAAC,CAAC,KAAKP,KAAK;IACnC,CAAC,MAAM,IAAII,GAAG,EAAE;MACd,OAAO,KAAK;IACd;EACF;EACA,OAAO,KAAK;AACd","ignoreList":[]}