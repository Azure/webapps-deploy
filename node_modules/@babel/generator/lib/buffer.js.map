{"version":3,"names":["spaceIndents","i","push","repeat","Buffer","constructor","map","indentChar","_map","_buf","_str","_appendCount","_last","_canMarkIdName","_indentChar","_queuedChar","_position","line","column","_sourcePosition","identifierName","undefined","identifierNamePos","filename","get","_flush","code","trimRight","decodedMap","rawMappings","result","getDecoded","__mergedMap","resultMap","value","Object","defineProperty","writable","mappings","getRawMappings","append","str","maybeNewline","_append","appendChar","char","_appendChar","queue","queuedChar","useSourcePos","indent","String","fromCharCode","isSpace","position","sourcePos","mark","len","length","hasMap","indexOf","last","removeLastSemicolon","getLastChar","checkQueue","getNewlineCount","hasContent","exactSource","loc","cb","source","prop","_normalizePosition","sourceWithOffset","columnOffset","pos","target","Math","max","getCurrentColumn","getCurrentLine","exports","default"],"sources":["../src/buffer.ts"],"sourcesContent":["import type SourceMap from \"./source-map.ts\";\nimport type { SourceLocation } from \"@babel/types\";\n\n// We inline this package\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport * as charcodes from \"charcodes\";\n\nexport type Loc = SourceLocation;\nexport type Pos = SourceLocation[\"start\"];\n\ntype SourcePosition = {\n  line: number | undefined;\n  column: number | undefined;\n  identifierName: string | undefined;\n  identifierNamePos: Pos | undefined;\n  filename: string | undefined;\n};\n\nconst spaceIndents: string[] = [];\nfor (let i = 0; i < 32; i++) {\n  spaceIndents.push(\" \".repeat(i * 2));\n}\n\nexport default class Buffer {\n  constructor(map: SourceMap | null, indentChar: string) {\n    this._map = map;\n    this._indentChar = indentChar;\n  }\n\n  _map: SourceMap | null = null;\n  _buf = \"\";\n  _str = \"\";\n  _appendCount = 0;\n  _last = 0;\n  _canMarkIdName = true;\n  _indentChar = \"\";\n  _queuedChar: typeof charcodes.space | typeof charcodes.semicolon | 0 = 0;\n\n  _position = {\n    line: 1,\n    column: 0,\n  };\n  _sourcePosition: SourcePosition = {\n    identifierName: undefined,\n    identifierNamePos: undefined,\n    line: undefined,\n    column: undefined,\n    filename: undefined,\n  };\n\n  /**\n   * Get the final string output from the buffer, along with the sourcemap if one exists.\n   */\n\n  get() {\n    const { _map, _last } = this;\n    if (this._queuedChar !== charcodes.space) {\n      this._flush();\n    }\n\n    // Whatever trim is used here should not execute a regex against the\n    // source string since it may be arbitrarily large after all transformations\n    const code =\n      _last === charcodes.lineFeed\n        ? (this._buf + this._str).trimRight()\n        : this._buf + this._str;\n\n    // Creating objects with getters is expensive.\n    if (_map === null) {\n      return {\n        code: code,\n        decodedMap: undefined,\n        map: null,\n        rawMappings: undefined,\n      };\n    }\n\n    const result = {\n      code: code,\n      // Decoded sourcemap is free to generate.\n      decodedMap: _map.getDecoded(),\n      // Used as a marker for backwards compatibility. We moved input map merging\n      // into the generator. We cannot merge the input map a second time, so the\n      // presence of this field tells us we've already done the work.\n      get __mergedMap() {\n        return this.map;\n      },\n      // Encoding the sourcemap is moderately CPU expensive.\n      get map() {\n        const resultMap = _map.get();\n        result.map = resultMap;\n        return resultMap;\n      },\n      set map(value) {\n        Object.defineProperty(result, \"map\", { value, writable: true });\n      },\n      // Retrieving the raw mappings is very memory intensive.\n      get rawMappings() {\n        const mappings = _map.getRawMappings();\n        result.rawMappings = mappings;\n        return mappings;\n      },\n      set rawMappings(value) {\n        Object.defineProperty(result, \"rawMappings\", { value, writable: true });\n      },\n    };\n\n    return result;\n  }\n\n  /**\n   * Add a string to the buffer that cannot be reverted.\n   */\n\n  append(str: string, maybeNewline: boolean): void {\n    this._flush();\n    this._append(str, maybeNewline);\n  }\n\n  appendChar(char: number): void {\n    this._flush();\n    this._appendChar(char, 1, true);\n  }\n\n  /**\n   * Add a string to the buffer than can be reverted.\n   */\n  queue(char: typeof charcodes.space | typeof charcodes.semicolon): void {\n    this._flush();\n    this._queuedChar = char;\n  }\n\n  _flush(): void {\n    const queuedChar = this._queuedChar;\n    if (queuedChar !== 0) {\n      this._appendChar(queuedChar, 1, true);\n      this._queuedChar = 0;\n    }\n  }\n\n  _appendChar(char: number, repeat: number, useSourcePos: boolean): void {\n    this._last = char;\n\n    if (char === -1) {\n      const indent =\n        repeat >= 64\n          ? this._indentChar.repeat(repeat)\n          : spaceIndents[repeat / 2];\n      this._str += indent;\n    } else {\n      this._str +=\n        repeat > 1\n          ? String.fromCharCode(char).repeat(repeat)\n          : String.fromCharCode(char);\n    }\n\n    const isSpace = char === charcodes.space;\n    const position = this._position;\n    if (char !== charcodes.lineFeed) {\n      if (this._map) {\n        const sourcePos = this._sourcePosition;\n        if (useSourcePos && sourcePos) {\n          this._map.mark(\n            position,\n            sourcePos.line,\n            sourcePos.column,\n            isSpace ? undefined : sourcePos.identifierName,\n            isSpace ? undefined : sourcePos.identifierNamePos,\n            sourcePos.filename,\n          );\n\n          if (!isSpace && this._canMarkIdName) {\n            sourcePos.identifierName = undefined;\n            sourcePos.identifierNamePos = undefined;\n          }\n        } else {\n          this._map.mark(position);\n        }\n      }\n\n      position.column += repeat;\n    } else {\n      position.line++;\n      position.column = 0;\n    }\n  }\n\n  _append(str: string, maybeNewline: boolean): void {\n    const len = str.length;\n    const position = this._position;\n    const sourcePos = this._sourcePosition;\n\n    this._last = -1; /* LAST_CHAR_KINDS.NORMAL */\n\n    if (++this._appendCount > 4096) {\n      // eslint-disable-next-line @typescript-eslint/no-unused-expressions\n      +this._str; // Unexplainable huge performance boost. Ref: https://github.com/davidmarkclements/flatstr License: MIT\n      this._buf += this._str;\n      this._str = str;\n      this._appendCount = 0;\n    } else {\n      this._str += str;\n    }\n\n    const hasMap = this._map !== null;\n\n    if (!maybeNewline && !hasMap) {\n      position.column += len;\n      return;\n    }\n\n    const { column, identifierName, identifierNamePos, filename } = sourcePos;\n    let line = sourcePos.line;\n\n    if (\n      (identifierName != null || identifierNamePos != null) &&\n      this._canMarkIdName\n    ) {\n      sourcePos.identifierName = undefined;\n      sourcePos.identifierNamePos = undefined;\n    }\n\n    // Search for newline chars. We search only for `\\n`, since both `\\r` and\n    // `\\r\\n` are normalized to `\\n` during parse. We exclude `\\u2028` and\n    // `\\u2029` for performance reasons, they're so uncommon that it's probably\n    // ok. It's also unclear how other sourcemap utilities handle them...\n    let i = str.indexOf(\"\\n\");\n    let last = 0;\n\n    // If the string starts with a newline char, then adding a mark is redundant.\n    // This catches both \"no newlines\" and \"newline after several chars\".\n    if (hasMap && i !== 0) {\n      this._map!.mark(\n        position,\n        line,\n        column,\n        identifierName,\n        identifierNamePos,\n        filename,\n      );\n    }\n\n    // Now, find each remaining newline char in the string.\n    while (i !== -1) {\n      position.line++;\n      position.column = 0;\n      last = i + 1;\n\n      // We mark the start of each line, which happens directly after this newline char\n      // unless this is the last char.\n      // When manually adding multi-line content (such as a comment), `line` will be `undefined`.\n      if (last < len && line !== undefined) {\n        line++;\n        if (hasMap) {\n          this._map!.mark(position, line, 0, undefined, undefined, filename);\n        }\n      }\n      i = str.indexOf(\"\\n\", last);\n    }\n    position.column += len - last;\n  }\n\n  removeLastSemicolon(): void {\n    if (this._queuedChar === charcodes.semicolon) {\n      this._queuedChar = 0;\n    }\n  }\n\n  getLastChar(checkQueue?: boolean): number {\n    if (!checkQueue) {\n      return this._last;\n    }\n    const queuedChar = this._queuedChar;\n    return queuedChar !== 0 ? queuedChar : this._last;\n  }\n\n  /**\n   * This will only detect at most 1 newline after a call to `flush()`,\n   * but this has not been found so far, and an accurate count can be achieved if needed later.\n   */\n  getNewlineCount(): number {\n    return this._queuedChar === 0 && this._last === charcodes.lineFeed ? 1 : 0;\n  }\n\n  hasContent(): boolean {\n    return this._last !== 0 /*|| this._queuedChar !== 0*/;\n  }\n\n  /**\n   * Certain sourcemap usecases expect mappings to be more accurate than\n   * Babel's generic sourcemap handling allows. For now, we special-case\n   * identifiers to allow for the primary cases to work.\n   * The goal of this line is to ensure that the map output from Babel will\n   * have an exact range on identifiers in the output code. Without this\n   * line, Babel would potentially include some number of trailing tokens\n   * that are printed after the identifier, but before another location has\n   * been assigned.\n   * This allows tooling like Rollup and Webpack to more accurately perform\n   * their own transformations. Most importantly, this allows the import/export\n   * transformations performed by those tools to loose less information when\n   * applying their own transformations on top of the code and map results\n   * generated by Babel itself.\n   *\n   * The primary example of this is the snippet:\n   *\n   *   import mod from \"mod\";\n   *   mod();\n   *\n   * With this line, there will be one mapping range over \"mod\" and another\n   * over \"();\", where previously it would have been a single mapping.\n   */\n  exactSource(loc: Loc, cb: () => void) {\n    if (!this._map) {\n      cb();\n      return;\n    }\n\n    this.source(\"start\", loc);\n    const identifierName = loc.identifierName;\n    const sourcePos = this._sourcePosition;\n    if (identifierName != null) {\n      this._canMarkIdName = false;\n      sourcePos.identifierName = identifierName;\n    }\n    cb();\n\n    if (identifierName != null) {\n      this._canMarkIdName = true;\n      sourcePos.identifierName = undefined;\n      sourcePos.identifierNamePos = undefined;\n    }\n    this.source(\"end\", loc);\n  }\n\n  /**\n   * Sets a given position as the current source location so generated code after this call\n   * will be given this position in the sourcemap.\n   */\n\n  source(prop: \"start\" | \"end\", loc: Loc): void {\n    if (!this._map) return;\n\n    // Since this is called extremely often, we reuse the same _sourcePosition\n    // object for the whole lifetime of the buffer.\n    this._normalizePosition(prop, loc, 0);\n  }\n\n  sourceWithOffset(\n    prop: \"start\" | \"end\",\n    loc: Loc,\n    columnOffset: number,\n  ): void {\n    if (!this._map) return;\n\n    this._normalizePosition(prop, loc, columnOffset);\n  }\n\n  _normalizePosition(prop: \"start\" | \"end\", loc: Loc, columnOffset: number) {\n    this._flush();\n\n    const pos = loc[prop];\n    const target = this._sourcePosition;\n\n    if (pos) {\n      target.line = pos.line;\n      // TODO: Fix https://github.com/babel/babel/issues/15712 in downstream\n      target.column = Math.max(pos.column + columnOffset, 0);\n      target.filename = loc.filename;\n    }\n  }\n\n  getCurrentColumn(): number {\n    return this._position.column + (this._queuedChar ? 1 : 0);\n  }\n\n  getCurrentLine(): number {\n    return this._position.line;\n  }\n}\n"],"mappings":";;;;;;AAkBA,MAAMA,YAAsB,GAAG,EAAE;AACjC,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,EAAE,EAAEA,CAAC,EAAE,EAAE;EAC3BD,YAAY,CAACE,IAAI,CAAC,GAAG,CAACC,MAAM,CAACF,CAAC,GAAG,CAAC,CAAC,CAAC;AACtC;AAEe,MAAMG,MAAM,CAAC;EAC1BC,WAAWA,CAACC,GAAqB,EAAEC,UAAkB,EAAE;IAAA,KAKvDC,IAAI,GAAqB,IAAI;IAAA,KAC7BC,IAAI,GAAG,EAAE;IAAA,KACTC,IAAI,GAAG,EAAE;IAAA,KACTC,YAAY,GAAG,CAAC;IAAA,KAChBC,KAAK,GAAG,CAAC;IAAA,KACTC,cAAc,GAAG,IAAI;IAAA,KACrBC,WAAW,GAAG,EAAE;IAAA,KAChBC,WAAW,GAA4D,CAAC;IAAA,KAExEC,SAAS,GAAG;MACVC,IAAI,EAAE,CAAC;MACPC,MAAM,EAAE;IACV,CAAC;IAAA,KACDC,eAAe,GAAmB;MAChCC,cAAc,EAAEC,SAAS;MACzBC,iBAAiB,EAAED,SAAS;MAC5BJ,IAAI,EAAEI,SAAS;MACfH,MAAM,EAAEG,SAAS;MACjBE,QAAQ,EAAEF;IACZ,CAAC;IAvBC,IAAI,CAACb,IAAI,GAAGF,GAAG;IACf,IAAI,CAACQ,WAAW,GAAGP,UAAU;EAC/B;EA2BAiB,GAAGA,CAAA,EAAG;IACJ,MAAM;MAAEhB,IAAI;MAAEI;IAAM,CAAC,GAAG,IAAI;IAC5B,IAAI,IAAI,CAACG,WAAW,OAAoB,EAAE;MACxC,IAAI,CAACU,MAAM,CAAC,CAAC;IACf;IAIA,MAAMC,IAAI,GACRd,KAAK,OAAuB,GACxB,CAAC,IAAI,CAACH,IAAI,GAAG,IAAI,CAACC,IAAI,EAAEiB,SAAS,CAAC,CAAC,GACnC,IAAI,CAAClB,IAAI,GAAG,IAAI,CAACC,IAAI;IAG3B,IAAIF,IAAI,KAAK,IAAI,EAAE;MACjB,OAAO;QACLkB,IAAI,EAAEA,IAAI;QACVE,UAAU,EAAEP,SAAS;QACrBf,GAAG,EAAE,IAAI;QACTuB,WAAW,EAAER;MACf,CAAC;IACH;IAEA,MAAMS,MAAM,GAAG;MACbJ,IAAI,EAAEA,IAAI;MAEVE,UAAU,EAAEpB,IAAI,CAACuB,UAAU,CAAC,CAAC;MAI7B,IAAIC,WAAWA,CAAA,EAAG;QAChB,OAAO,IAAI,CAAC1B,GAAG;MACjB,CAAC;MAED,IAAIA,GAAGA,CAAA,EAAG;QACR,MAAM2B,SAAS,GAAGzB,IAAI,CAACgB,GAAG,CAAC,CAAC;QAC5BM,MAAM,CAACxB,GAAG,GAAG2B,SAAS;QACtB,OAAOA,SAAS;MAClB,CAAC;MACD,IAAI3B,GAAGA,CAAC4B,KAAK,EAAE;QACbC,MAAM,CAACC,cAAc,CAACN,MAAM,EAAE,KAAK,EAAE;UAAEI,KAAK;UAAEG,QAAQ,EAAE;QAAK,CAAC,CAAC;MACjE,CAAC;MAED,IAAIR,WAAWA,CAAA,EAAG;QAChB,MAAMS,QAAQ,GAAG9B,IAAI,CAAC+B,cAAc,CAAC,CAAC;QACtCT,MAAM,CAACD,WAAW,GAAGS,QAAQ;QAC7B,OAAOA,QAAQ;MACjB,CAAC;MACD,IAAIT,WAAWA,CAACK,KAAK,EAAE;QACrBC,MAAM,CAACC,cAAc,CAACN,MAAM,EAAE,aAAa,EAAE;UAAEI,KAAK;UAAEG,QAAQ,EAAE;QAAK,CAAC,CAAC;MACzE;IACF,CAAC;IAED,OAAOP,MAAM;EACf;EAMAU,MAAMA,CAACC,GAAW,EAAEC,YAAqB,EAAQ;IAC/C,IAAI,CAACjB,MAAM,CAAC,CAAC;IACb,IAAI,CAACkB,OAAO,CAACF,GAAG,EAAEC,YAAY,CAAC;EACjC;EAEAE,UAAUA,CAACC,IAAY,EAAQ;IAC7B,IAAI,CAACpB,MAAM,CAAC,CAAC;IACb,IAAI,CAACqB,WAAW,CAACD,IAAI,EAAE,CAAC,EAAE,IAAI,CAAC;EACjC;EAKAE,KAAKA,CAACF,IAAyD,EAAQ;IACrE,IAAI,CAACpB,MAAM,CAAC,CAAC;IACb,IAAI,CAACV,WAAW,GAAG8B,IAAI;EACzB;EAEApB,MAAMA,CAAA,EAAS;IACb,MAAMuB,UAAU,GAAG,IAAI,CAACjC,WAAW;IACnC,IAAIiC,UAAU,KAAK,CAAC,EAAE;MACpB,IAAI,CAACF,WAAW,CAACE,UAAU,EAAE,CAAC,EAAE,IAAI,CAAC;MACrC,IAAI,CAACjC,WAAW,GAAG,CAAC;IACtB;EACF;EAEA+B,WAAWA,CAACD,IAAY,EAAE1C,MAAc,EAAE8C,YAAqB,EAAQ;IACrE,IAAI,CAACrC,KAAK,GAAGiC,IAAI;IAEjB,IAAIA,IAAI,KAAK,CAAC,CAAC,EAAE;MACf,MAAMK,MAAM,GACV/C,MAAM,IAAI,EAAE,GACR,IAAI,CAACW,WAAW,CAACX,MAAM,CAACA,MAAM,CAAC,GAC/BH,YAAY,CAACG,MAAM,GAAG,CAAC,CAAC;MAC9B,IAAI,CAACO,IAAI,IAAIwC,MAAM;IACrB,CAAC,MAAM;MACL,IAAI,CAACxC,IAAI,IACPP,MAAM,GAAG,CAAC,GACNgD,MAAM,CAACC,YAAY,CAACP,IAAI,CAAC,CAAC1C,MAAM,CAACA,MAAM,CAAC,GACxCgD,MAAM,CAACC,YAAY,CAACP,IAAI,CAAC;IACjC;IAEA,MAAMQ,OAAO,GAAGR,IAAI,OAAoB;IACxC,MAAMS,QAAQ,GAAG,IAAI,CAACtC,SAAS;IAC/B,IAAI6B,IAAI,OAAuB,EAAE;MAC/B,IAAI,IAAI,CAACrC,IAAI,EAAE;QACb,MAAM+C,SAAS,GAAG,IAAI,CAACpC,eAAe;QACtC,IAAI8B,YAAY,IAAIM,SAAS,EAAE;UAC7B,IAAI,CAAC/C,IAAI,CAACgD,IAAI,CACZF,QAAQ,EACRC,SAAS,CAACtC,IAAI,EACdsC,SAAS,CAACrC,MAAM,EAChBmC,OAAO,GAAGhC,SAAS,GAAGkC,SAAS,CAACnC,cAAc,EAC9CiC,OAAO,GAAGhC,SAAS,GAAGkC,SAAS,CAACjC,iBAAiB,EACjDiC,SAAS,CAAChC,QACZ,CAAC;UAED,IAAI,CAAC8B,OAAO,IAAI,IAAI,CAACxC,cAAc,EAAE;YACnC0C,SAAS,CAACnC,cAAc,GAAGC,SAAS;YACpCkC,SAAS,CAACjC,iBAAiB,GAAGD,SAAS;UACzC;QACF,CAAC,MAAM;UACL,IAAI,CAACb,IAAI,CAACgD,IAAI,CAACF,QAAQ,CAAC;QAC1B;MACF;MAEAA,QAAQ,CAACpC,MAAM,IAAIf,MAAM;IAC3B,CAAC,MAAM;MACLmD,QAAQ,CAACrC,IAAI,EAAE;MACfqC,QAAQ,CAACpC,MAAM,GAAG,CAAC;IACrB;EACF;EAEAyB,OAAOA,CAACF,GAAW,EAAEC,YAAqB,EAAQ;IAChD,MAAMe,GAAG,GAAGhB,GAAG,CAACiB,MAAM;IACtB,MAAMJ,QAAQ,GAAG,IAAI,CAACtC,SAAS;IAC/B,MAAMuC,SAAS,GAAG,IAAI,CAACpC,eAAe;IAEtC,IAAI,CAACP,KAAK,GAAG,CAAC,CAAC;IAEf,IAAI,EAAE,IAAI,CAACD,YAAY,GAAG,IAAI,EAAE;MAE9B,CAAC,IAAI,CAACD,IAAI;MACV,IAAI,CAACD,IAAI,IAAI,IAAI,CAACC,IAAI;MACtB,IAAI,CAACA,IAAI,GAAG+B,GAAG;MACf,IAAI,CAAC9B,YAAY,GAAG,CAAC;IACvB,CAAC,MAAM;MACL,IAAI,CAACD,IAAI,IAAI+B,GAAG;IAClB;IAEA,MAAMkB,MAAM,GAAG,IAAI,CAACnD,IAAI,KAAK,IAAI;IAEjC,IAAI,CAACkC,YAAY,IAAI,CAACiB,MAAM,EAAE;MAC5BL,QAAQ,CAACpC,MAAM,IAAIuC,GAAG;MACtB;IACF;IAEA,MAAM;MAAEvC,MAAM;MAAEE,cAAc;MAAEE,iBAAiB;MAAEC;IAAS,CAAC,GAAGgC,SAAS;IACzE,IAAItC,IAAI,GAAGsC,SAAS,CAACtC,IAAI;IAEzB,IACE,CAACG,cAAc,IAAI,IAAI,IAAIE,iBAAiB,IAAI,IAAI,KACpD,IAAI,CAACT,cAAc,EACnB;MACA0C,SAAS,CAACnC,cAAc,GAAGC,SAAS;MACpCkC,SAAS,CAACjC,iBAAiB,GAAGD,SAAS;IACzC;IAMA,IAAIpB,CAAC,GAAGwC,GAAG,CAACmB,OAAO,CAAC,IAAI,CAAC;IACzB,IAAIC,IAAI,GAAG,CAAC;IAIZ,IAAIF,MAAM,IAAI1D,CAAC,KAAK,CAAC,EAAE;MACrB,IAAI,CAACO,IAAI,CAAEgD,IAAI,CACbF,QAAQ,EACRrC,IAAI,EACJC,MAAM,EACNE,cAAc,EACdE,iBAAiB,EACjBC,QACF,CAAC;IACH;IAGA,OAAOtB,CAAC,KAAK,CAAC,CAAC,EAAE;MACfqD,QAAQ,CAACrC,IAAI,EAAE;MACfqC,QAAQ,CAACpC,MAAM,GAAG,CAAC;MACnB2C,IAAI,GAAG5D,CAAC,GAAG,CAAC;MAKZ,IAAI4D,IAAI,GAAGJ,GAAG,IAAIxC,IAAI,KAAKI,SAAS,EAAE;QACpCJ,IAAI,EAAE;QACN,IAAI0C,MAAM,EAAE;UACV,IAAI,CAACnD,IAAI,CAAEgD,IAAI,CAACF,QAAQ,EAAErC,IAAI,EAAE,CAAC,EAAEI,SAAS,EAAEA,SAAS,EAAEE,QAAQ,CAAC;QACpE;MACF;MACAtB,CAAC,GAAGwC,GAAG,CAACmB,OAAO,CAAC,IAAI,EAAEC,IAAI,CAAC;IAC7B;IACAP,QAAQ,CAACpC,MAAM,IAAIuC,GAAG,GAAGI,IAAI;EAC/B;EAEAC,mBAAmBA,CAAA,EAAS;IAC1B,IAAI,IAAI,CAAC/C,WAAW,OAAwB,EAAE;MAC5C,IAAI,CAACA,WAAW,GAAG,CAAC;IACtB;EACF;EAEAgD,WAAWA,CAACC,UAAoB,EAAU;IACxC,IAAI,CAACA,UAAU,EAAE;MACf,OAAO,IAAI,CAACpD,KAAK;IACnB;IACA,MAAMoC,UAAU,GAAG,IAAI,CAACjC,WAAW;IACnC,OAAOiC,UAAU,KAAK,CAAC,GAAGA,UAAU,GAAG,IAAI,CAACpC,KAAK;EACnD;EAMAqD,eAAeA,CAAA,EAAW;IACxB,OAAO,IAAI,CAAClD,WAAW,KAAK,CAAC,IAAI,IAAI,CAACH,KAAK,OAAuB,GAAG,CAAC,GAAG,CAAC;EAC5E;EAEAsD,UAAUA,CAAA,EAAY;IACpB,OAAO,IAAI,CAACtD,KAAK,KAAK,CAAC;EACzB;EAyBAuD,WAAWA,CAACC,GAAQ,EAAEC,EAAc,EAAE;IACpC,IAAI,CAAC,IAAI,CAAC7D,IAAI,EAAE;MACd6D,EAAE,CAAC,CAAC;MACJ;IACF;IAEA,IAAI,CAACC,MAAM,CAAC,OAAO,EAAEF,GAAG,CAAC;IACzB,MAAMhD,cAAc,GAAGgD,GAAG,CAAChD,cAAc;IACzC,MAAMmC,SAAS,GAAG,IAAI,CAACpC,eAAe;IACtC,IAAIC,cAAc,IAAI,IAAI,EAAE;MAC1B,IAAI,CAACP,cAAc,GAAG,KAAK;MAC3B0C,SAAS,CAACnC,cAAc,GAAGA,cAAc;IAC3C;IACAiD,EAAE,CAAC,CAAC;IAEJ,IAAIjD,cAAc,IAAI,IAAI,EAAE;MAC1B,IAAI,CAACP,cAAc,GAAG,IAAI;MAC1B0C,SAAS,CAACnC,cAAc,GAAGC,SAAS;MACpCkC,SAAS,CAACjC,iBAAiB,GAAGD,SAAS;IACzC;IACA,IAAI,CAACiD,MAAM,CAAC,KAAK,EAAEF,GAAG,CAAC;EACzB;EAOAE,MAAMA,CAACC,IAAqB,EAAEH,GAAQ,EAAQ;IAC5C,IAAI,CAAC,IAAI,CAAC5D,IAAI,EAAE;IAIhB,IAAI,CAACgE,kBAAkB,CAACD,IAAI,EAAEH,GAAG,EAAE,CAAC,CAAC;EACvC;EAEAK,gBAAgBA,CACdF,IAAqB,EACrBH,GAAQ,EACRM,YAAoB,EACd;IACN,IAAI,CAAC,IAAI,CAAClE,IAAI,EAAE;IAEhB,IAAI,CAACgE,kBAAkB,CAACD,IAAI,EAAEH,GAAG,EAAEM,YAAY,CAAC;EAClD;EAEAF,kBAAkBA,CAACD,IAAqB,EAAEH,GAAQ,EAAEM,YAAoB,EAAE;IACxE,IAAI,CAACjD,MAAM,CAAC,CAAC;IAEb,MAAMkD,GAAG,GAAGP,GAAG,CAACG,IAAI,CAAC;IACrB,MAAMK,MAAM,GAAG,IAAI,CAACzD,eAAe;IAEnC,IAAIwD,GAAG,EAAE;MACPC,MAAM,CAAC3D,IAAI,GAAG0D,GAAG,CAAC1D,IAAI;MAEtB2D,MAAM,CAAC1D,MAAM,GAAG2D,IAAI,CAACC,GAAG,CAACH,GAAG,CAACzD,MAAM,GAAGwD,YAAY,EAAE,CAAC,CAAC;MACtDE,MAAM,CAACrD,QAAQ,GAAG6C,GAAG,CAAC7C,QAAQ;IAChC;EACF;EAEAwD,gBAAgBA,CAAA,EAAW;IACzB,OAAO,IAAI,CAAC/D,SAAS,CAACE,MAAM,IAAI,IAAI,CAACH,WAAW,GAAG,CAAC,GAAG,CAAC,CAAC;EAC3D;EAEAiE,cAAcA,CAAA,EAAW;IACvB,OAAO,IAAI,CAAChE,SAAS,CAACC,IAAI;EAC5B;AACF;AAACgE,OAAA,CAAAC,OAAA,GAAA9E,MAAA","ignoreList":[]}